// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,Default)]
pub struct ProtoSpec {
    // message fields
    specHeading: ::protobuf::SingularField<::std::string::String>,
    items: ::protobuf::RepeatedField<ProtoItem>,
    isTableDriven: ::std::option::Option<bool>,
    preHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    postHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    fileName: ::protobuf::SingularField<::std::string::String>,
    tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoSpec {
    pub fn new() -> ProtoSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoSpec {
        static mut instance: ::protobuf::lazy::Lazy<ProtoSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoSpec,
        };
        unsafe {
            instance.get(|| {
                ProtoSpec {
                    specHeading: ::protobuf::SingularField::none(),
                    items: ::protobuf::RepeatedField::new(),
                    isTableDriven: ::std::option::Option::None,
                    preHookFailure: ::protobuf::SingularPtrField::none(),
                    postHookFailure: ::protobuf::SingularPtrField::none(),
                    fileName: ::protobuf::SingularField::none(),
                    tags: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string specHeading = 1;

    pub fn clear_specHeading(&mut self) {
        self.specHeading.clear();
    }

    pub fn has_specHeading(&self) -> bool {
        self.specHeading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specHeading(&mut self, v: ::std::string::String) {
        self.specHeading = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specHeading<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.specHeading.is_none() {
            self.specHeading.set_default();
        };
        self.specHeading.as_mut().unwrap()
    }

    // Take field
    pub fn take_specHeading(&mut self) -> ::std::string::String {
        self.specHeading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_specHeading<'a>(&'a self) -> &'a str {
        match self.specHeading.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .gauge.messages.ProtoItem items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ProtoItem>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoItem> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ProtoItem> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items<'a>(&'a self) -> &'a [ProtoItem] {
        &self.items
    }

    // required bool isTableDriven = 3;

    pub fn clear_isTableDriven(&mut self) {
        self.isTableDriven = ::std::option::Option::None;
    }

    pub fn has_isTableDriven(&self) -> bool {
        self.isTableDriven.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isTableDriven(&mut self, v: bool) {
        self.isTableDriven = ::std::option::Option::Some(v);
    }

    pub fn get_isTableDriven<'a>(&self) -> bool {
        self.isTableDriven.unwrap_or(false)
    }

    // optional .gauge.messages.ProtoHookFailure preHookFailure = 4;

    pub fn clear_preHookFailure(&mut self) {
        self.preHookFailure.clear();
    }

    pub fn has_preHookFailure(&self) -> bool {
        self.preHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preHookFailure(&mut self, v: ProtoHookFailure) {
        self.preHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.preHookFailure.is_none() {
            self.preHookFailure.set_default();
        };
        self.preHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_preHookFailure(&mut self) -> ProtoHookFailure {
        self.preHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_preHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.preHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // optional .gauge.messages.ProtoHookFailure postHookFailure = 5;

    pub fn clear_postHookFailure(&mut self) {
        self.postHookFailure.clear();
    }

    pub fn has_postHookFailure(&self) -> bool {
        self.postHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postHookFailure(&mut self, v: ProtoHookFailure) {
        self.postHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.postHookFailure.is_none() {
            self.postHookFailure.set_default();
        };
        self.postHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_postHookFailure(&mut self) -> ProtoHookFailure {
        self.postHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_postHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.postHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // required string fileName = 6;

    pub fn clear_fileName(&mut self) {
        self.fileName.clear();
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName.set_default();
        };
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fileName<'a>(&'a self) -> &'a str {
        match self.fileName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string tags = 7;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    pub fn get_tags<'a>(&'a self) -> &'a [::std::string::String] {
        &self.tags
    }
}

impl ::protobuf::Message for ProtoSpec {
    fn is_initialized(&self) -> bool {
        if self.specHeading.is_none() {
            return false;
        };
        if self.isTableDriven.is_none() {
            return false;
        };
        if self.fileName.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.specHeading));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.isTableDriven = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preHookFailure));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postHookFailure));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileName));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.specHeading.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.items.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.isTableDriven.is_some() {
            my_size += 2;
        };
        for value in self.preHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.postHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.fileName.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.tags.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.specHeading.as_ref() {
            try!(os.write_string(1, &v));
        };
        for v in self.items.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.isTableDriven {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.postHookFailure.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.fileName.as_ref() {
            try!(os.write_string(6, &v));
        };
        for v in self.tags.iter() {
            try!(os.write_string(7, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoSpec>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoSpec {
    fn new() -> ProtoSpec {
        ProtoSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "specHeading",
                    ProtoSpec::has_specHeading,
                    ProtoSpec::get_specHeading,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "items",
                    ProtoSpec::get_items,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "isTableDriven",
                    ProtoSpec::has_isTableDriven,
                    ProtoSpec::get_isTableDriven,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "preHookFailure",
                    ProtoSpec::has_preHookFailure,
                    ProtoSpec::get_preHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "postHookFailure",
                    ProtoSpec::has_postHookFailure,
                    ProtoSpec::get_postHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "fileName",
                    ProtoSpec::has_fileName,
                    ProtoSpec::get_fileName,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "tags",
                    ProtoSpec::get_tags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoSpec>(
                    "ProtoSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoSpec {
    fn clear(&mut self) {
        self.clear_specHeading();
        self.clear_items();
        self.clear_isTableDriven();
        self.clear_preHookFailure();
        self.clear_postHookFailure();
        self.clear_fileName();
        self.clear_tags();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoSpec {
    fn eq(&self, other: &ProtoSpec) -> bool {
        self.specHeading == other.specHeading &&
        self.items == other.items &&
        self.isTableDriven == other.isTableDriven &&
        self.preHookFailure == other.preHookFailure &&
        self.postHookFailure == other.postHookFailure &&
        self.fileName == other.fileName &&
        self.tags == other.tags &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoItem {
    // message fields
    itemType: ::std::option::Option<ProtoItem_ItemType>,
    step: ::protobuf::SingularPtrField<ProtoStep>,
    concept: ::protobuf::SingularPtrField<ProtoConcept>,
    scenario: ::protobuf::SingularPtrField<ProtoScenario>,
    tableDrivenScenario: ::protobuf::SingularPtrField<ProtoTableDrivenScenario>,
    comment: ::protobuf::SingularPtrField<ProtoComment>,
    table: ::protobuf::SingularPtrField<ProtoTable>,
    tags: ::protobuf::SingularPtrField<ProtoTags>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoItem {
    pub fn new() -> ProtoItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoItem {
        static mut instance: ::protobuf::lazy::Lazy<ProtoItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoItem,
        };
        unsafe {
            instance.get(|| {
                ProtoItem {
                    itemType: ::std::option::Option::None,
                    step: ::protobuf::SingularPtrField::none(),
                    concept: ::protobuf::SingularPtrField::none(),
                    scenario: ::protobuf::SingularPtrField::none(),
                    tableDrivenScenario: ::protobuf::SingularPtrField::none(),
                    comment: ::protobuf::SingularPtrField::none(),
                    table: ::protobuf::SingularPtrField::none(),
                    tags: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .gauge.messages.ProtoItem.ItemType itemType = 1;

    pub fn clear_itemType(&mut self) {
        self.itemType = ::std::option::Option::None;
    }

    pub fn has_itemType(&self) -> bool {
        self.itemType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemType(&mut self, v: ProtoItem_ItemType) {
        self.itemType = ::std::option::Option::Some(v);
    }

    pub fn get_itemType<'a>(&self) -> ProtoItem_ItemType {
        self.itemType.unwrap_or(ProtoItem_ItemType::Step)
    }

    // optional .gauge.messages.ProtoStep step = 2;

    pub fn clear_step(&mut self) {
        self.step.clear();
    }

    pub fn has_step(&self) -> bool {
        self.step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: ProtoStep) {
        self.step = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_step<'a>(&'a mut self) -> &'a mut ProtoStep {
        if self.step.is_none() {
            self.step.set_default();
        };
        self.step.as_mut().unwrap()
    }

    // Take field
    pub fn take_step(&mut self) -> ProtoStep {
        self.step.take().unwrap_or_else(|| ProtoStep::new())
    }

    pub fn get_step<'a>(&'a self) -> &'a ProtoStep {
        self.step.as_ref().unwrap_or_else(|| ProtoStep::default_instance())
    }

    // optional .gauge.messages.ProtoConcept concept = 3;

    pub fn clear_concept(&mut self) {
        self.concept.clear();
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: ProtoConcept) {
        self.concept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept<'a>(&'a mut self) -> &'a mut ProtoConcept {
        if self.concept.is_none() {
            self.concept.set_default();
        };
        self.concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept(&mut self) -> ProtoConcept {
        self.concept.take().unwrap_or_else(|| ProtoConcept::new())
    }

    pub fn get_concept<'a>(&'a self) -> &'a ProtoConcept {
        self.concept.as_ref().unwrap_or_else(|| ProtoConcept::default_instance())
    }

    // optional .gauge.messages.ProtoScenario scenario = 4;

    pub fn clear_scenario(&mut self) {
        self.scenario.clear();
    }

    pub fn has_scenario(&self) -> bool {
        self.scenario.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenario(&mut self, v: ProtoScenario) {
        self.scenario = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scenario<'a>(&'a mut self) -> &'a mut ProtoScenario {
        if self.scenario.is_none() {
            self.scenario.set_default();
        };
        self.scenario.as_mut().unwrap()
    }

    // Take field
    pub fn take_scenario(&mut self) -> ProtoScenario {
        self.scenario.take().unwrap_or_else(|| ProtoScenario::new())
    }

    pub fn get_scenario<'a>(&'a self) -> &'a ProtoScenario {
        self.scenario.as_ref().unwrap_or_else(|| ProtoScenario::default_instance())
    }

    // optional .gauge.messages.ProtoTableDrivenScenario tableDrivenScenario = 5;

    pub fn clear_tableDrivenScenario(&mut self) {
        self.tableDrivenScenario.clear();
    }

    pub fn has_tableDrivenScenario(&self) -> bool {
        self.tableDrivenScenario.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tableDrivenScenario(&mut self, v: ProtoTableDrivenScenario) {
        self.tableDrivenScenario = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tableDrivenScenario<'a>(&'a mut self) -> &'a mut ProtoTableDrivenScenario {
        if self.tableDrivenScenario.is_none() {
            self.tableDrivenScenario.set_default();
        };
        self.tableDrivenScenario.as_mut().unwrap()
    }

    // Take field
    pub fn take_tableDrivenScenario(&mut self) -> ProtoTableDrivenScenario {
        self.tableDrivenScenario.take().unwrap_or_else(|| ProtoTableDrivenScenario::new())
    }

    pub fn get_tableDrivenScenario<'a>(&'a self) -> &'a ProtoTableDrivenScenario {
        self.tableDrivenScenario.as_ref().unwrap_or_else(|| ProtoTableDrivenScenario::default_instance())
    }

    // optional .gauge.messages.ProtoComment comment = 6;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ProtoComment) {
        self.comment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment<'a>(&'a mut self) -> &'a mut ProtoComment {
        if self.comment.is_none() {
            self.comment.set_default();
        };
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ProtoComment {
        self.comment.take().unwrap_or_else(|| ProtoComment::new())
    }

    pub fn get_comment<'a>(&'a self) -> &'a ProtoComment {
        self.comment.as_ref().unwrap_or_else(|| ProtoComment::default_instance())
    }

    // optional .gauge.messages.ProtoTable table = 7;

    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    pub fn has_table(&self) -> bool {
        self.table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ProtoTable) {
        self.table = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table<'a>(&'a mut self) -> &'a mut ProtoTable {
        if self.table.is_none() {
            self.table.set_default();
        };
        self.table.as_mut().unwrap()
    }

    // Take field
    pub fn take_table(&mut self) -> ProtoTable {
        self.table.take().unwrap_or_else(|| ProtoTable::new())
    }

    pub fn get_table<'a>(&'a self) -> &'a ProtoTable {
        self.table.as_ref().unwrap_or_else(|| ProtoTable::default_instance())
    }

    // optional .gauge.messages.ProtoTags tags = 8;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ProtoTags) {
        self.tags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags<'a>(&'a mut self) -> &'a mut ProtoTags {
        if self.tags.is_none() {
            self.tags.set_default();
        };
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ProtoTags {
        self.tags.take().unwrap_or_else(|| ProtoTags::new())
    }

    pub fn get_tags<'a>(&'a self) -> &'a ProtoTags {
        self.tags.as_ref().unwrap_or_else(|| ProtoTags::default_instance())
    }
}

impl ::protobuf::Message for ProtoItem {
    fn is_initialized(&self) -> bool {
        if self.itemType.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.itemType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.step));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scenario));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tableDrivenScenario));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comment));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tags));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.itemType.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.step.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.concept.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.scenario.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.tableDrivenScenario.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.comment.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.table.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.tags.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemType {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.step.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.concept.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.scenario.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.tableDrivenScenario.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.comment.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.table.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.tags.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoItem>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoItem {
    fn new() -> ProtoItem {
        ProtoItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "itemType",
                    ProtoItem::has_itemType,
                    ProtoItem::get_itemType,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "step",
                    ProtoItem::has_step,
                    ProtoItem::get_step,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "concept",
                    ProtoItem::has_concept,
                    ProtoItem::get_concept,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scenario",
                    ProtoItem::has_scenario,
                    ProtoItem::get_scenario,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "tableDrivenScenario",
                    ProtoItem::has_tableDrivenScenario,
                    ProtoItem::get_tableDrivenScenario,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "comment",
                    ProtoItem::has_comment,
                    ProtoItem::get_comment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "table",
                    ProtoItem::has_table,
                    ProtoItem::get_table,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "tags",
                    ProtoItem::has_tags,
                    ProtoItem::get_tags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoItem>(
                    "ProtoItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoItem {
    fn clear(&mut self) {
        self.clear_itemType();
        self.clear_step();
        self.clear_concept();
        self.clear_scenario();
        self.clear_tableDrivenScenario();
        self.clear_comment();
        self.clear_table();
        self.clear_tags();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoItem {
    fn eq(&self, other: &ProtoItem) -> bool {
        self.itemType == other.itemType &&
        self.step == other.step &&
        self.concept == other.concept &&
        self.scenario == other.scenario &&
        self.tableDrivenScenario == other.tableDrivenScenario &&
        self.comment == other.comment &&
        self.table == other.table &&
        self.tags == other.tags &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtoItem_ItemType {
    Step = 1,
    Comment = 2,
    Concept = 3,
    Scenario = 4,
    TableDrivenScenario = 5,
    Table = 6,
    Tags = 7,
}

impl ::protobuf::ProtobufEnum for ProtoItem_ItemType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoItem_ItemType> {
        match value {
            1 => ::std::option::Option::Some(ProtoItem_ItemType::Step),
            2 => ::std::option::Option::Some(ProtoItem_ItemType::Comment),
            3 => ::std::option::Option::Some(ProtoItem_ItemType::Concept),
            4 => ::std::option::Option::Some(ProtoItem_ItemType::Scenario),
            5 => ::std::option::Option::Some(ProtoItem_ItemType::TableDrivenScenario),
            6 => ::std::option::Option::Some(ProtoItem_ItemType::Table),
            7 => ::std::option::Option::Some(ProtoItem_ItemType::Tags),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtoItem_ItemType] = &[
            ProtoItem_ItemType::Step,
            ProtoItem_ItemType::Comment,
            ProtoItem_ItemType::Concept,
            ProtoItem_ItemType::Scenario,
            ProtoItem_ItemType::TableDrivenScenario,
            ProtoItem_ItemType::Table,
            ProtoItem_ItemType::Tags,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ProtoItem_ItemType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ProtoItem_ItemType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ProtoItem_ItemType {
}

#[derive(Clone,Default)]
pub struct ProtoScenario {
    // message fields
    scenarioHeading: ::protobuf::SingularField<::std::string::String>,
    failed: ::std::option::Option<bool>,
    contexts: ::protobuf::RepeatedField<ProtoItem>,
    scenarioItems: ::protobuf::RepeatedField<ProtoItem>,
    preHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    postHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    tags: ::protobuf::RepeatedField<::std::string::String>,
    executionTime: ::std::option::Option<i64>,
    skipped: ::std::option::Option<bool>,
    skipErrors: ::protobuf::RepeatedField<::std::string::String>,
    ID: ::protobuf::SingularField<::std::string::String>,
    tearDownSteps: ::protobuf::RepeatedField<ProtoItem>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoScenario {
    pub fn new() -> ProtoScenario {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoScenario {
        static mut instance: ::protobuf::lazy::Lazy<ProtoScenario> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoScenario,
        };
        unsafe {
            instance.get(|| {
                ProtoScenario {
                    scenarioHeading: ::protobuf::SingularField::none(),
                    failed: ::std::option::Option::None,
                    contexts: ::protobuf::RepeatedField::new(),
                    scenarioItems: ::protobuf::RepeatedField::new(),
                    preHookFailure: ::protobuf::SingularPtrField::none(),
                    postHookFailure: ::protobuf::SingularPtrField::none(),
                    tags: ::protobuf::RepeatedField::new(),
                    executionTime: ::std::option::Option::None,
                    skipped: ::std::option::Option::None,
                    skipErrors: ::protobuf::RepeatedField::new(),
                    ID: ::protobuf::SingularField::none(),
                    tearDownSteps: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string scenarioHeading = 1;

    pub fn clear_scenarioHeading(&mut self) {
        self.scenarioHeading.clear();
    }

    pub fn has_scenarioHeading(&self) -> bool {
        self.scenarioHeading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioHeading(&mut self, v: ::std::string::String) {
        self.scenarioHeading = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scenarioHeading<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.scenarioHeading.is_none() {
            self.scenarioHeading.set_default();
        };
        self.scenarioHeading.as_mut().unwrap()
    }

    // Take field
    pub fn take_scenarioHeading(&mut self) -> ::std::string::String {
        self.scenarioHeading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_scenarioHeading<'a>(&'a self) -> &'a str {
        match self.scenarioHeading.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required bool failed = 2;

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    pub fn get_failed<'a>(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    // repeated .gauge.messages.ProtoItem contexts = 3;

    pub fn clear_contexts(&mut self) {
        self.contexts.clear();
    }

    // Param is passed by value, moved
    pub fn set_contexts(&mut self, v: ::protobuf::RepeatedField<ProtoItem>) {
        self.contexts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contexts<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoItem> {
        &mut self.contexts
    }

    // Take field
    pub fn take_contexts(&mut self) -> ::protobuf::RepeatedField<ProtoItem> {
        ::std::mem::replace(&mut self.contexts, ::protobuf::RepeatedField::new())
    }

    pub fn get_contexts<'a>(&'a self) -> &'a [ProtoItem] {
        &self.contexts
    }

    // repeated .gauge.messages.ProtoItem scenarioItems = 4;

    pub fn clear_scenarioItems(&mut self) {
        self.scenarioItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_scenarioItems(&mut self, v: ::protobuf::RepeatedField<ProtoItem>) {
        self.scenarioItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scenarioItems<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoItem> {
        &mut self.scenarioItems
    }

    // Take field
    pub fn take_scenarioItems(&mut self) -> ::protobuf::RepeatedField<ProtoItem> {
        ::std::mem::replace(&mut self.scenarioItems, ::protobuf::RepeatedField::new())
    }

    pub fn get_scenarioItems<'a>(&'a self) -> &'a [ProtoItem] {
        &self.scenarioItems
    }

    // optional .gauge.messages.ProtoHookFailure preHookFailure = 5;

    pub fn clear_preHookFailure(&mut self) {
        self.preHookFailure.clear();
    }

    pub fn has_preHookFailure(&self) -> bool {
        self.preHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preHookFailure(&mut self, v: ProtoHookFailure) {
        self.preHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.preHookFailure.is_none() {
            self.preHookFailure.set_default();
        };
        self.preHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_preHookFailure(&mut self) -> ProtoHookFailure {
        self.preHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_preHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.preHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // optional .gauge.messages.ProtoHookFailure postHookFailure = 6;

    pub fn clear_postHookFailure(&mut self) {
        self.postHookFailure.clear();
    }

    pub fn has_postHookFailure(&self) -> bool {
        self.postHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postHookFailure(&mut self, v: ProtoHookFailure) {
        self.postHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.postHookFailure.is_none() {
            self.postHookFailure.set_default();
        };
        self.postHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_postHookFailure(&mut self) -> ProtoHookFailure {
        self.postHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_postHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.postHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // repeated string tags = 7;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    pub fn get_tags<'a>(&'a self) -> &'a [::std::string::String] {
        &self.tags
    }

    // optional int64 executionTime = 8;

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    pub fn get_executionTime<'a>(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    // required bool skipped = 9;

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: bool) {
        self.skipped = ::std::option::Option::Some(v);
    }

    pub fn get_skipped<'a>(&self) -> bool {
        self.skipped.unwrap_or(false)
    }

    // repeated string skipErrors = 10;

    pub fn clear_skipErrors(&mut self) {
        self.skipErrors.clear();
    }

    // Param is passed by value, moved
    pub fn set_skipErrors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.skipErrors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_skipErrors<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.skipErrors
    }

    // Take field
    pub fn take_skipErrors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.skipErrors, ::protobuf::RepeatedField::new())
    }

    pub fn get_skipErrors<'a>(&'a self) -> &'a [::std::string::String] {
        &self.skipErrors
    }

    // optional string ID = 11;

    pub fn clear_ID(&mut self) {
        self.ID.clear();
    }

    pub fn has_ID(&self) -> bool {
        self.ID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ID.is_none() {
            self.ID.set_default();
        };
        self.ID.as_mut().unwrap()
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        self.ID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ID<'a>(&'a self) -> &'a str {
        match self.ID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .gauge.messages.ProtoItem tearDownSteps = 12;

    pub fn clear_tearDownSteps(&mut self) {
        self.tearDownSteps.clear();
    }

    // Param is passed by value, moved
    pub fn set_tearDownSteps(&mut self, v: ::protobuf::RepeatedField<ProtoItem>) {
        self.tearDownSteps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tearDownSteps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoItem> {
        &mut self.tearDownSteps
    }

    // Take field
    pub fn take_tearDownSteps(&mut self) -> ::protobuf::RepeatedField<ProtoItem> {
        ::std::mem::replace(&mut self.tearDownSteps, ::protobuf::RepeatedField::new())
    }

    pub fn get_tearDownSteps<'a>(&'a self) -> &'a [ProtoItem] {
        &self.tearDownSteps
    }
}

impl ::protobuf::Message for ProtoScenario {
    fn is_initialized(&self) -> bool {
        if self.scenarioHeading.is_none() {
            return false;
        };
        if self.failed.is_none() {
            return false;
        };
        if self.skipped.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scenarioHeading));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.failed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contexts));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scenarioItems));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preHookFailure));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postHookFailure));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.executionTime = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.skipped = ::std::option::Option::Some(tmp);
                },
                10 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.skipErrors));
                },
                11 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ID));
                },
                12 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tearDownSteps));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.scenarioHeading.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.failed.is_some() {
            my_size += 2;
        };
        for value in self.contexts.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.scenarioItems.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.preHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.postHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.tags.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.executionTime.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.skipped.is_some() {
            my_size += 2;
        };
        for value in self.skipErrors.iter() {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in self.ID.iter() {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in self.tearDownSteps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scenarioHeading.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.failed {
            try!(os.write_bool(2, v));
        };
        for v in self.contexts.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.scenarioItems.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.postHookFailure.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.tags.iter() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.executionTime {
            try!(os.write_int64(8, v));
        };
        if let Some(v) = self.skipped {
            try!(os.write_bool(9, v));
        };
        for v in self.skipErrors.iter() {
            try!(os.write_string(10, &v));
        };
        if let Some(v) = self.ID.as_ref() {
            try!(os.write_string(11, &v));
        };
        for v in self.tearDownSteps.iter() {
            try!(os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoScenario>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoScenario {
    fn new() -> ProtoScenario {
        ProtoScenario::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoScenario>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "scenarioHeading",
                    ProtoScenario::has_scenarioHeading,
                    ProtoScenario::get_scenarioHeading,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "failed",
                    ProtoScenario::has_failed,
                    ProtoScenario::get_failed,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "contexts",
                    ProtoScenario::get_contexts,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "scenarioItems",
                    ProtoScenario::get_scenarioItems,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "preHookFailure",
                    ProtoScenario::has_preHookFailure,
                    ProtoScenario::get_preHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "postHookFailure",
                    ProtoScenario::has_postHookFailure,
                    ProtoScenario::get_postHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "tags",
                    ProtoScenario::get_tags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "executionTime",
                    ProtoScenario::has_executionTime,
                    ProtoScenario::get_executionTime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "skipped",
                    ProtoScenario::has_skipped,
                    ProtoScenario::get_skipped,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "skipErrors",
                    ProtoScenario::get_skipErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ID",
                    ProtoScenario::has_ID,
                    ProtoScenario::get_ID,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "tearDownSteps",
                    ProtoScenario::get_tearDownSteps,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoScenario>(
                    "ProtoScenario",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoScenario {
    fn clear(&mut self) {
        self.clear_scenarioHeading();
        self.clear_failed();
        self.clear_contexts();
        self.clear_scenarioItems();
        self.clear_preHookFailure();
        self.clear_postHookFailure();
        self.clear_tags();
        self.clear_executionTime();
        self.clear_skipped();
        self.clear_skipErrors();
        self.clear_ID();
        self.clear_tearDownSteps();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoScenario {
    fn eq(&self, other: &ProtoScenario) -> bool {
        self.scenarioHeading == other.scenarioHeading &&
        self.failed == other.failed &&
        self.contexts == other.contexts &&
        self.scenarioItems == other.scenarioItems &&
        self.preHookFailure == other.preHookFailure &&
        self.postHookFailure == other.postHookFailure &&
        self.tags == other.tags &&
        self.executionTime == other.executionTime &&
        self.skipped == other.skipped &&
        self.skipErrors == other.skipErrors &&
        self.ID == other.ID &&
        self.tearDownSteps == other.tearDownSteps &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoScenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoTableDrivenScenario {
    // message fields
    scenarios: ::protobuf::RepeatedField<ProtoScenario>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoTableDrivenScenario {
    pub fn new() -> ProtoTableDrivenScenario {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoTableDrivenScenario {
        static mut instance: ::protobuf::lazy::Lazy<ProtoTableDrivenScenario> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoTableDrivenScenario,
        };
        unsafe {
            instance.get(|| {
                ProtoTableDrivenScenario {
                    scenarios: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .gauge.messages.ProtoScenario scenarios = 1;

    pub fn clear_scenarios(&mut self) {
        self.scenarios.clear();
    }

    // Param is passed by value, moved
    pub fn set_scenarios(&mut self, v: ::protobuf::RepeatedField<ProtoScenario>) {
        self.scenarios = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scenarios<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoScenario> {
        &mut self.scenarios
    }

    // Take field
    pub fn take_scenarios(&mut self) -> ::protobuf::RepeatedField<ProtoScenario> {
        ::std::mem::replace(&mut self.scenarios, ::protobuf::RepeatedField::new())
    }

    pub fn get_scenarios<'a>(&'a self) -> &'a [ProtoScenario] {
        &self.scenarios
    }
}

impl ::protobuf::Message for ProtoTableDrivenScenario {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scenarios));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.scenarios.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.scenarios.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoTableDrivenScenario>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoTableDrivenScenario {
    fn new() -> ProtoTableDrivenScenario {
        ProtoTableDrivenScenario::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoTableDrivenScenario>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "scenarios",
                    ProtoTableDrivenScenario::get_scenarios,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoTableDrivenScenario>(
                    "ProtoTableDrivenScenario",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoTableDrivenScenario {
    fn clear(&mut self) {
        self.clear_scenarios();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoTableDrivenScenario {
    fn eq(&self, other: &ProtoTableDrivenScenario) -> bool {
        self.scenarios == other.scenarios &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoTableDrivenScenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoStep {
    // message fields
    actualText: ::protobuf::SingularField<::std::string::String>,
    parsedText: ::protobuf::SingularField<::std::string::String>,
    fragments: ::protobuf::RepeatedField<Fragment>,
    stepExecutionResult: ::protobuf::SingularPtrField<ProtoStepExecutionResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoStep {
    pub fn new() -> ProtoStep {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoStep {
        static mut instance: ::protobuf::lazy::Lazy<ProtoStep> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoStep,
        };
        unsafe {
            instance.get(|| {
                ProtoStep {
                    actualText: ::protobuf::SingularField::none(),
                    parsedText: ::protobuf::SingularField::none(),
                    fragments: ::protobuf::RepeatedField::new(),
                    stepExecutionResult: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string actualText = 1;

    pub fn clear_actualText(&mut self) {
        self.actualText.clear();
    }

    pub fn has_actualText(&self) -> bool {
        self.actualText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actualText(&mut self, v: ::std::string::String) {
        self.actualText = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actualText<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.actualText.is_none() {
            self.actualText.set_default();
        };
        self.actualText.as_mut().unwrap()
    }

    // Take field
    pub fn take_actualText(&mut self) -> ::std::string::String {
        self.actualText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_actualText<'a>(&'a self) -> &'a str {
        match self.actualText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string parsedText = 2;

    pub fn clear_parsedText(&mut self) {
        self.parsedText.clear();
    }

    pub fn has_parsedText(&self) -> bool {
        self.parsedText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parsedText(&mut self, v: ::std::string::String) {
        self.parsedText = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parsedText<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.parsedText.is_none() {
            self.parsedText.set_default();
        };
        self.parsedText.as_mut().unwrap()
    }

    // Take field
    pub fn take_parsedText(&mut self) -> ::std::string::String {
        self.parsedText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_parsedText<'a>(&'a self) -> &'a str {
        match self.parsedText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .gauge.messages.Fragment fragments = 3;

    pub fn clear_fragments(&mut self) {
        self.fragments.clear();
    }

    // Param is passed by value, moved
    pub fn set_fragments(&mut self, v: ::protobuf::RepeatedField<Fragment>) {
        self.fragments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fragments<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Fragment> {
        &mut self.fragments
    }

    // Take field
    pub fn take_fragments(&mut self) -> ::protobuf::RepeatedField<Fragment> {
        ::std::mem::replace(&mut self.fragments, ::protobuf::RepeatedField::new())
    }

    pub fn get_fragments<'a>(&'a self) -> &'a [Fragment] {
        &self.fragments
    }

    // optional .gauge.messages.ProtoStepExecutionResult stepExecutionResult = 4;

    pub fn clear_stepExecutionResult(&mut self) {
        self.stepExecutionResult.clear();
    }

    pub fn has_stepExecutionResult(&self) -> bool {
        self.stepExecutionResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepExecutionResult(&mut self, v: ProtoStepExecutionResult) {
        self.stepExecutionResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stepExecutionResult<'a>(&'a mut self) -> &'a mut ProtoStepExecutionResult {
        if self.stepExecutionResult.is_none() {
            self.stepExecutionResult.set_default();
        };
        self.stepExecutionResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_stepExecutionResult(&mut self) -> ProtoStepExecutionResult {
        self.stepExecutionResult.take().unwrap_or_else(|| ProtoStepExecutionResult::new())
    }

    pub fn get_stepExecutionResult<'a>(&'a self) -> &'a ProtoStepExecutionResult {
        self.stepExecutionResult.as_ref().unwrap_or_else(|| ProtoStepExecutionResult::default_instance())
    }
}

impl ::protobuf::Message for ProtoStep {
    fn is_initialized(&self) -> bool {
        if self.actualText.is_none() {
            return false;
        };
        if self.parsedText.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.actualText));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parsedText));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fragments));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stepExecutionResult));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.actualText.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.parsedText.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.fragments.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.stepExecutionResult.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.actualText.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.parsedText.as_ref() {
            try!(os.write_string(2, &v));
        };
        for v in self.fragments.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.stepExecutionResult.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoStep>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoStep {
    fn new() -> ProtoStep {
        ProtoStep::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoStep>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "actualText",
                    ProtoStep::has_actualText,
                    ProtoStep::get_actualText,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "parsedText",
                    ProtoStep::has_parsedText,
                    ProtoStep::get_parsedText,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "fragments",
                    ProtoStep::get_fragments,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stepExecutionResult",
                    ProtoStep::has_stepExecutionResult,
                    ProtoStep::get_stepExecutionResult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoStep>(
                    "ProtoStep",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoStep {
    fn clear(&mut self) {
        self.clear_actualText();
        self.clear_parsedText();
        self.clear_fragments();
        self.clear_stepExecutionResult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoStep {
    fn eq(&self, other: &ProtoStep) -> bool {
        self.actualText == other.actualText &&
        self.parsedText == other.parsedText &&
        self.fragments == other.fragments &&
        self.stepExecutionResult == other.stepExecutionResult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoConcept {
    // message fields
    conceptStep: ::protobuf::SingularPtrField<ProtoStep>,
    steps: ::protobuf::RepeatedField<ProtoItem>,
    conceptExecutionResult: ::protobuf::SingularPtrField<ProtoStepExecutionResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoConcept {
    pub fn new() -> ProtoConcept {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoConcept {
        static mut instance: ::protobuf::lazy::Lazy<ProtoConcept> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoConcept,
        };
        unsafe {
            instance.get(|| {
                ProtoConcept {
                    conceptStep: ::protobuf::SingularPtrField::none(),
                    steps: ::protobuf::RepeatedField::new(),
                    conceptExecutionResult: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .gauge.messages.ProtoStep conceptStep = 1;

    pub fn clear_conceptStep(&mut self) {
        self.conceptStep.clear();
    }

    pub fn has_conceptStep(&self) -> bool {
        self.conceptStep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conceptStep(&mut self, v: ProtoStep) {
        self.conceptStep = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conceptStep<'a>(&'a mut self) -> &'a mut ProtoStep {
        if self.conceptStep.is_none() {
            self.conceptStep.set_default();
        };
        self.conceptStep.as_mut().unwrap()
    }

    // Take field
    pub fn take_conceptStep(&mut self) -> ProtoStep {
        self.conceptStep.take().unwrap_or_else(|| ProtoStep::new())
    }

    pub fn get_conceptStep<'a>(&'a self) -> &'a ProtoStep {
        self.conceptStep.as_ref().unwrap_or_else(|| ProtoStep::default_instance())
    }

    // repeated .gauge.messages.ProtoItem steps = 2;

    pub fn clear_steps(&mut self) {
        self.steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_steps(&mut self, v: ::protobuf::RepeatedField<ProtoItem>) {
        self.steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoItem> {
        &mut self.steps
    }

    // Take field
    pub fn take_steps(&mut self) -> ::protobuf::RepeatedField<ProtoItem> {
        ::std::mem::replace(&mut self.steps, ::protobuf::RepeatedField::new())
    }

    pub fn get_steps<'a>(&'a self) -> &'a [ProtoItem] {
        &self.steps
    }

    // optional .gauge.messages.ProtoStepExecutionResult conceptExecutionResult = 3;

    pub fn clear_conceptExecutionResult(&mut self) {
        self.conceptExecutionResult.clear();
    }

    pub fn has_conceptExecutionResult(&self) -> bool {
        self.conceptExecutionResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conceptExecutionResult(&mut self, v: ProtoStepExecutionResult) {
        self.conceptExecutionResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conceptExecutionResult<'a>(&'a mut self) -> &'a mut ProtoStepExecutionResult {
        if self.conceptExecutionResult.is_none() {
            self.conceptExecutionResult.set_default();
        };
        self.conceptExecutionResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_conceptExecutionResult(&mut self) -> ProtoStepExecutionResult {
        self.conceptExecutionResult.take().unwrap_or_else(|| ProtoStepExecutionResult::new())
    }

    pub fn get_conceptExecutionResult<'a>(&'a self) -> &'a ProtoStepExecutionResult {
        self.conceptExecutionResult.as_ref().unwrap_or_else(|| ProtoStepExecutionResult::default_instance())
    }
}

impl ::protobuf::Message for ProtoConcept {
    fn is_initialized(&self) -> bool {
        if self.conceptStep.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conceptStep));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.steps));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conceptExecutionResult));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.conceptStep.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.steps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.conceptExecutionResult.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.conceptStep.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.steps.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.conceptExecutionResult.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoConcept>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoConcept {
    fn new() -> ProtoConcept {
        ProtoConcept::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoConcept>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "conceptStep",
                    ProtoConcept::has_conceptStep,
                    ProtoConcept::get_conceptStep,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "steps",
                    ProtoConcept::get_steps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "conceptExecutionResult",
                    ProtoConcept::has_conceptExecutionResult,
                    ProtoConcept::get_conceptExecutionResult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoConcept>(
                    "ProtoConcept",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoConcept {
    fn clear(&mut self) {
        self.clear_conceptStep();
        self.clear_steps();
        self.clear_conceptExecutionResult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoConcept {
    fn eq(&self, other: &ProtoConcept) -> bool {
        self.conceptStep == other.conceptStep &&
        self.steps == other.steps &&
        self.conceptExecutionResult == other.conceptExecutionResult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoConcept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoTags {
    // message fields
    tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoTags {
    pub fn new() -> ProtoTags {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoTags {
        static mut instance: ::protobuf::lazy::Lazy<ProtoTags> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoTags,
        };
        unsafe {
            instance.get(|| {
                ProtoTags {
                    tags: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated string tags = 1;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    pub fn get_tags<'a>(&'a self) -> &'a [::std::string::String] {
        &self.tags
    }
}

impl ::protobuf::Message for ProtoTags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.tags.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.tags.iter() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoTags>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoTags {
    fn new() -> ProtoTags {
        ProtoTags::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoTags>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "tags",
                    ProtoTags::get_tags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoTags>(
                    "ProtoTags",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoTags {
    fn clear(&mut self) {
        self.clear_tags();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoTags {
    fn eq(&self, other: &ProtoTags) -> bool {
        self.tags == other.tags &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoTags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Fragment {
    // message fields
    fragmentType: ::std::option::Option<Fragment_FragmentType>,
    text: ::protobuf::SingularField<::std::string::String>,
    parameter: ::protobuf::SingularPtrField<Parameter>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Fragment {
    pub fn new() -> Fragment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Fragment {
        static mut instance: ::protobuf::lazy::Lazy<Fragment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Fragment,
        };
        unsafe {
            instance.get(|| {
                Fragment {
                    fragmentType: ::std::option::Option::None,
                    text: ::protobuf::SingularField::none(),
                    parameter: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .gauge.messages.Fragment.FragmentType fragmentType = 1;

    pub fn clear_fragmentType(&mut self) {
        self.fragmentType = ::std::option::Option::None;
    }

    pub fn has_fragmentType(&self) -> bool {
        self.fragmentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fragmentType(&mut self, v: Fragment_FragmentType) {
        self.fragmentType = ::std::option::Option::Some(v);
    }

    pub fn get_fragmentType<'a>(&self) -> Fragment_FragmentType {
        self.fragmentType.unwrap_or(Fragment_FragmentType::Text)
    }

    // optional string text = 2;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .gauge.messages.Parameter parameter = 3;

    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    pub fn has_parameter(&self) -> bool {
        self.parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: Parameter) {
        self.parameter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter<'a>(&'a mut self) -> &'a mut Parameter {
        if self.parameter.is_none() {
            self.parameter.set_default();
        };
        self.parameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter(&mut self) -> Parameter {
        self.parameter.take().unwrap_or_else(|| Parameter::new())
    }

    pub fn get_parameter<'a>(&'a self) -> &'a Parameter {
        self.parameter.as_ref().unwrap_or_else(|| Parameter::default_instance())
    }
}

impl ::protobuf::Message for Fragment {
    fn is_initialized(&self) -> bool {
        if self.fragmentType.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.fragmentType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parameter));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.fragmentType.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.parameter.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fragmentType {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.text.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.parameter.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Fragment>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Fragment {
    fn new() -> Fragment {
        Fragment::new()
    }

    fn descriptor_static(_: ::std::option::Option<Fragment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "fragmentType",
                    Fragment::has_fragmentType,
                    Fragment::get_fragmentType,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "text",
                    Fragment::has_text,
                    Fragment::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "parameter",
                    Fragment::has_parameter,
                    Fragment::get_parameter,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Fragment>(
                    "Fragment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Fragment {
    fn clear(&mut self) {
        self.clear_fragmentType();
        self.clear_text();
        self.clear_parameter();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Fragment {
    fn eq(&self, other: &Fragment) -> bool {
        self.fragmentType == other.fragmentType &&
        self.text == other.text &&
        self.parameter == other.parameter &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Fragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Fragment_FragmentType {
    Text = 1,
    Parameter = 2,
}

impl ::protobuf::ProtobufEnum for Fragment_FragmentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fragment_FragmentType> {
        match value {
            1 => ::std::option::Option::Some(Fragment_FragmentType::Text),
            2 => ::std::option::Option::Some(Fragment_FragmentType::Parameter),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Fragment_FragmentType] = &[
            Fragment_FragmentType::Text,
            Fragment_FragmentType::Parameter,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Fragment_FragmentType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Fragment_FragmentType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Fragment_FragmentType {
}

#[derive(Clone,Default)]
pub struct Parameter {
    // message fields
    parameterType: ::std::option::Option<Parameter_ParameterType>,
    value: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    table: ::protobuf::SingularPtrField<ProtoTable>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameter {
        static mut instance: ::protobuf::lazy::Lazy<Parameter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameter,
        };
        unsafe {
            instance.get(|| {
                Parameter {
                    parameterType: ::std::option::Option::None,
                    value: ::protobuf::SingularField::none(),
                    name: ::protobuf::SingularField::none(),
                    table: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .gauge.messages.Parameter.ParameterType parameterType = 1;

    pub fn clear_parameterType(&mut self) {
        self.parameterType = ::std::option::Option::None;
    }

    pub fn has_parameterType(&self) -> bool {
        self.parameterType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterType(&mut self, v: Parameter_ParameterType) {
        self.parameterType = ::std::option::Option::Some(v);
    }

    pub fn get_parameterType<'a>(&self) -> Parameter_ParameterType {
        self.parameterType.unwrap_or(Parameter_ParameterType::Static)
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .gauge.messages.ProtoTable table = 4;

    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    pub fn has_table(&self) -> bool {
        self.table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ProtoTable) {
        self.table = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table<'a>(&'a mut self) -> &'a mut ProtoTable {
        if self.table.is_none() {
            self.table.set_default();
        };
        self.table.as_mut().unwrap()
    }

    // Take field
    pub fn take_table(&mut self) -> ProtoTable {
        self.table.take().unwrap_or_else(|| ProtoTable::new())
    }

    pub fn get_table<'a>(&'a self) -> &'a ProtoTable {
        self.table.as_ref().unwrap_or_else(|| ProtoTable::default_instance())
    }
}

impl ::protobuf::Message for Parameter {
    fn is_initialized(&self) -> bool {
        if self.parameterType.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.parameterType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.parameterType.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.table.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parameterType {
            try!(os.write_enum(1, v as i32));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.table.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Parameter>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameter {
    fn new() -> Parameter {
        Parameter::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameter>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "parameterType",
                    Parameter::has_parameterType,
                    Parameter::get_parameterType,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Parameter::has_value,
                    Parameter::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Parameter::has_name,
                    Parameter::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "table",
                    Parameter::has_table,
                    Parameter::get_table,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameter>(
                    "Parameter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameter {
    fn clear(&mut self) {
        self.clear_parameterType();
        self.clear_value();
        self.clear_name();
        self.clear_table();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Parameter {
    fn eq(&self, other: &Parameter) -> bool {
        self.parameterType == other.parameterType &&
        self.value == other.value &&
        self.name == other.name &&
        self.table == other.table &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Parameter_ParameterType {
    Static = 1,
    Dynamic = 2,
    Special_String = 3,
    Special_Table = 4,
    Table = 5,
}

impl ::protobuf::ProtobufEnum for Parameter_ParameterType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Parameter_ParameterType> {
        match value {
            1 => ::std::option::Option::Some(Parameter_ParameterType::Static),
            2 => ::std::option::Option::Some(Parameter_ParameterType::Dynamic),
            3 => ::std::option::Option::Some(Parameter_ParameterType::Special_String),
            4 => ::std::option::Option::Some(Parameter_ParameterType::Special_Table),
            5 => ::std::option::Option::Some(Parameter_ParameterType::Table),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Parameter_ParameterType] = &[
            Parameter_ParameterType::Static,
            Parameter_ParameterType::Dynamic,
            Parameter_ParameterType::Special_String,
            Parameter_ParameterType::Special_Table,
            Parameter_ParameterType::Table,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Parameter_ParameterType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Parameter_ParameterType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Parameter_ParameterType {
}

#[derive(Clone,Default)]
pub struct ProtoComment {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoComment {
    pub fn new() -> ProtoComment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoComment {
        static mut instance: ::protobuf::lazy::Lazy<ProtoComment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoComment,
        };
        unsafe {
            instance.get(|| {
                ProtoComment {
                    text: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string text = 1;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ProtoComment {
    fn is_initialized(&self) -> bool {
        if self.text.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.text.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoComment>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoComment {
    fn new() -> ProtoComment {
        ProtoComment::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoComment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "text",
                    ProtoComment::has_text,
                    ProtoComment::get_text,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoComment>(
                    "ProtoComment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoComment {
    fn clear(&mut self) {
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoComment {
    fn eq(&self, other: &ProtoComment) -> bool {
        self.text == other.text &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoComment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoTable {
    // message fields
    headers: ::protobuf::SingularPtrField<ProtoTableRow>,
    rows: ::protobuf::RepeatedField<ProtoTableRow>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoTable {
    pub fn new() -> ProtoTable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoTable {
        static mut instance: ::protobuf::lazy::Lazy<ProtoTable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoTable,
        };
        unsafe {
            instance.get(|| {
                ProtoTable {
                    headers: ::protobuf::SingularPtrField::none(),
                    rows: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .gauge.messages.ProtoTableRow headers = 1;

    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    pub fn has_headers(&self) -> bool {
        self.headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ProtoTableRow) {
        self.headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headers<'a>(&'a mut self) -> &'a mut ProtoTableRow {
        if self.headers.is_none() {
            self.headers.set_default();
        };
        self.headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_headers(&mut self) -> ProtoTableRow {
        self.headers.take().unwrap_or_else(|| ProtoTableRow::new())
    }

    pub fn get_headers<'a>(&'a self) -> &'a ProtoTableRow {
        self.headers.as_ref().unwrap_or_else(|| ProtoTableRow::default_instance())
    }

    // repeated .gauge.messages.ProtoTableRow rows = 2;

    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<ProtoTableRow>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoTableRow> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<ProtoTableRow> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }

    pub fn get_rows<'a>(&'a self) -> &'a [ProtoTableRow] {
        &self.rows
    }
}

impl ::protobuf::Message for ProtoTable {
    fn is_initialized(&self) -> bool {
        if self.headers.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headers));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.headers.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.rows.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.headers.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.rows.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoTable>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoTable {
    fn new() -> ProtoTable {
        ProtoTable::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoTable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "headers",
                    ProtoTable::has_headers,
                    ProtoTable::get_headers,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "rows",
                    ProtoTable::get_rows,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoTable>(
                    "ProtoTable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoTable {
    fn clear(&mut self) {
        self.clear_headers();
        self.clear_rows();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoTable {
    fn eq(&self, other: &ProtoTable) -> bool {
        self.headers == other.headers &&
        self.rows == other.rows &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoTableRow {
    // message fields
    cells: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoTableRow {
    pub fn new() -> ProtoTableRow {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoTableRow {
        static mut instance: ::protobuf::lazy::Lazy<ProtoTableRow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoTableRow,
        };
        unsafe {
            instance.get(|| {
                ProtoTableRow {
                    cells: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated string cells = 1;

    pub fn clear_cells(&mut self) {
        self.cells.clear();
    }

    // Param is passed by value, moved
    pub fn set_cells(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cells<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cells
    }

    // Take field
    pub fn take_cells(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cells, ::protobuf::RepeatedField::new())
    }

    pub fn get_cells<'a>(&'a self) -> &'a [::std::string::String] {
        &self.cells
    }
}

impl ::protobuf::Message for ProtoTableRow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cells));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.cells.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.cells.iter() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoTableRow>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoTableRow {
    fn new() -> ProtoTableRow {
        ProtoTableRow::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoTableRow>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "cells",
                    ProtoTableRow::get_cells,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoTableRow>(
                    "ProtoTableRow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoTableRow {
    fn clear(&mut self) {
        self.clear_cells();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoTableRow {
    fn eq(&self, other: &ProtoTableRow) -> bool {
        self.cells == other.cells &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoTableRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoStepExecutionResult {
    // message fields
    executionResult: ::protobuf::SingularPtrField<ProtoExecutionResult>,
    preHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    postHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    skipped: ::std::option::Option<bool>,
    skippedReason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoStepExecutionResult {
    pub fn new() -> ProtoStepExecutionResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoStepExecutionResult {
        static mut instance: ::protobuf::lazy::Lazy<ProtoStepExecutionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoStepExecutionResult,
        };
        unsafe {
            instance.get(|| {
                ProtoStepExecutionResult {
                    executionResult: ::protobuf::SingularPtrField::none(),
                    preHookFailure: ::protobuf::SingularPtrField::none(),
                    postHookFailure: ::protobuf::SingularPtrField::none(),
                    skipped: ::std::option::Option::None,
                    skippedReason: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .gauge.messages.ProtoExecutionResult executionResult = 1;

    pub fn clear_executionResult(&mut self) {
        self.executionResult.clear();
    }

    pub fn has_executionResult(&self) -> bool {
        self.executionResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionResult(&mut self, v: ProtoExecutionResult) {
        self.executionResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executionResult<'a>(&'a mut self) -> &'a mut ProtoExecutionResult {
        if self.executionResult.is_none() {
            self.executionResult.set_default();
        };
        self.executionResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_executionResult(&mut self) -> ProtoExecutionResult {
        self.executionResult.take().unwrap_or_else(|| ProtoExecutionResult::new())
    }

    pub fn get_executionResult<'a>(&'a self) -> &'a ProtoExecutionResult {
        self.executionResult.as_ref().unwrap_or_else(|| ProtoExecutionResult::default_instance())
    }

    // optional .gauge.messages.ProtoHookFailure preHookFailure = 2;

    pub fn clear_preHookFailure(&mut self) {
        self.preHookFailure.clear();
    }

    pub fn has_preHookFailure(&self) -> bool {
        self.preHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preHookFailure(&mut self, v: ProtoHookFailure) {
        self.preHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.preHookFailure.is_none() {
            self.preHookFailure.set_default();
        };
        self.preHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_preHookFailure(&mut self) -> ProtoHookFailure {
        self.preHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_preHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.preHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // optional .gauge.messages.ProtoHookFailure postHookFailure = 3;

    pub fn clear_postHookFailure(&mut self) {
        self.postHookFailure.clear();
    }

    pub fn has_postHookFailure(&self) -> bool {
        self.postHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postHookFailure(&mut self, v: ProtoHookFailure) {
        self.postHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.postHookFailure.is_none() {
            self.postHookFailure.set_default();
        };
        self.postHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_postHookFailure(&mut self) -> ProtoHookFailure {
        self.postHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_postHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.postHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // required bool skipped = 4;

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: bool) {
        self.skipped = ::std::option::Option::Some(v);
    }

    pub fn get_skipped<'a>(&self) -> bool {
        self.skipped.unwrap_or(false)
    }

    // optional string skippedReason = 5;

    pub fn clear_skippedReason(&mut self) {
        self.skippedReason.clear();
    }

    pub fn has_skippedReason(&self) -> bool {
        self.skippedReason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skippedReason(&mut self, v: ::std::string::String) {
        self.skippedReason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_skippedReason<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.skippedReason.is_none() {
            self.skippedReason.set_default();
        };
        self.skippedReason.as_mut().unwrap()
    }

    // Take field
    pub fn take_skippedReason(&mut self) -> ::std::string::String {
        self.skippedReason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_skippedReason<'a>(&'a self) -> &'a str {
        match self.skippedReason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ProtoStepExecutionResult {
    fn is_initialized(&self) -> bool {
        if self.skipped.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executionResult));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preHookFailure));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postHookFailure));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.skipped = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.skippedReason));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executionResult.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.preHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.postHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.skipped.is_some() {
            my_size += 2;
        };
        for value in self.skippedReason.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executionResult.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.postHookFailure.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.skipped {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.skippedReason.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoStepExecutionResult>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoStepExecutionResult {
    fn new() -> ProtoStepExecutionResult {
        ProtoStepExecutionResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoStepExecutionResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executionResult",
                    ProtoStepExecutionResult::has_executionResult,
                    ProtoStepExecutionResult::get_executionResult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "preHookFailure",
                    ProtoStepExecutionResult::has_preHookFailure,
                    ProtoStepExecutionResult::get_preHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "postHookFailure",
                    ProtoStepExecutionResult::has_postHookFailure,
                    ProtoStepExecutionResult::get_postHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "skipped",
                    ProtoStepExecutionResult::has_skipped,
                    ProtoStepExecutionResult::get_skipped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "skippedReason",
                    ProtoStepExecutionResult::has_skippedReason,
                    ProtoStepExecutionResult::get_skippedReason,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoStepExecutionResult>(
                    "ProtoStepExecutionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoStepExecutionResult {
    fn clear(&mut self) {
        self.clear_executionResult();
        self.clear_preHookFailure();
        self.clear_postHookFailure();
        self.clear_skipped();
        self.clear_skippedReason();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoStepExecutionResult {
    fn eq(&self, other: &ProtoStepExecutionResult) -> bool {
        self.executionResult == other.executionResult &&
        self.preHookFailure == other.preHookFailure &&
        self.postHookFailure == other.postHookFailure &&
        self.skipped == other.skipped &&
        self.skippedReason == other.skippedReason &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoStepExecutionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoExecutionResult {
    // message fields
    failed: ::std::option::Option<bool>,
    recoverableError: ::std::option::Option<bool>,
    errorMessage: ::protobuf::SingularField<::std::string::String>,
    stackTrace: ::protobuf::SingularField<::std::string::String>,
    screenShot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    executionTime: ::std::option::Option<i64>,
    message: ::protobuf::RepeatedField<::std::string::String>,
    errorType: ::std::option::Option<ProtoExecutionResult_ErrorType>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoExecutionResult {
    pub fn new() -> ProtoExecutionResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoExecutionResult {
        static mut instance: ::protobuf::lazy::Lazy<ProtoExecutionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoExecutionResult,
        };
        unsafe {
            instance.get(|| {
                ProtoExecutionResult {
                    failed: ::std::option::Option::None,
                    recoverableError: ::std::option::Option::None,
                    errorMessage: ::protobuf::SingularField::none(),
                    stackTrace: ::protobuf::SingularField::none(),
                    screenShot: ::protobuf::SingularField::none(),
                    executionTime: ::std::option::Option::None,
                    message: ::protobuf::RepeatedField::new(),
                    errorType: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bool failed = 1;

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    pub fn get_failed<'a>(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    // optional bool recoverableError = 2;

    pub fn clear_recoverableError(&mut self) {
        self.recoverableError = ::std::option::Option::None;
    }

    pub fn has_recoverableError(&self) -> bool {
        self.recoverableError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recoverableError(&mut self, v: bool) {
        self.recoverableError = ::std::option::Option::Some(v);
    }

    pub fn get_recoverableError<'a>(&self) -> bool {
        self.recoverableError.unwrap_or(false)
    }

    // optional string errorMessage = 3;

    pub fn clear_errorMessage(&mut self) {
        self.errorMessage.clear();
    }

    pub fn has_errorMessage(&self) -> bool {
        self.errorMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.errorMessage.is_none() {
            self.errorMessage.set_default();
        };
        self.errorMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        self.errorMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_errorMessage<'a>(&'a self) -> &'a str {
        match self.errorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string stackTrace = 4;

    pub fn clear_stackTrace(&mut self) {
        self.stackTrace.clear();
    }

    pub fn has_stackTrace(&self) -> bool {
        self.stackTrace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stackTrace(&mut self, v: ::std::string::String) {
        self.stackTrace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stackTrace<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.stackTrace.is_none() {
            self.stackTrace.set_default();
        };
        self.stackTrace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stackTrace(&mut self) -> ::std::string::String {
        self.stackTrace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_stackTrace<'a>(&'a self) -> &'a str {
        match self.stackTrace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes screenShot = 5;

    pub fn clear_screenShot(&mut self) {
        self.screenShot.clear();
    }

    pub fn has_screenShot(&self) -> bool {
        self.screenShot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenShot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenShot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenShot<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.screenShot.is_none() {
            self.screenShot.set_default();
        };
        self.screenShot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenShot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenShot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_screenShot<'a>(&'a self) -> &'a [u8] {
        match self.screenShot.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // required int64 executionTime = 6;

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    pub fn get_executionTime<'a>(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    // repeated string message = 7;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.message, ::protobuf::RepeatedField::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a [::std::string::String] {
        &self.message
    }

    // optional .gauge.messages.ProtoExecutionResult.ErrorType errorType = 8;

    pub fn clear_errorType(&mut self) {
        self.errorType = ::std::option::Option::None;
    }

    pub fn has_errorType(&self) -> bool {
        self.errorType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorType(&mut self, v: ProtoExecutionResult_ErrorType) {
        self.errorType = ::std::option::Option::Some(v);
    }

    pub fn get_errorType<'a>(&self) -> ProtoExecutionResult_ErrorType {
        self.errorType.unwrap_or(ProtoExecutionResult_ErrorType::ASSERTION)
    }
}

impl ::protobuf::Message for ProtoExecutionResult {
    fn is_initialized(&self) -> bool {
        if self.failed.is_none() {
            return false;
        };
        if self.executionTime.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.failed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.recoverableError = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stackTrace));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenShot));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.executionTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.errorType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.failed.is_some() {
            my_size += 2;
        };
        if self.recoverableError.is_some() {
            my_size += 2;
        };
        for value in self.errorMessage.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.stackTrace.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.screenShot.iter() {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in self.executionTime.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.errorType.iter() {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.failed {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.recoverableError {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.errorMessage.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.stackTrace.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.screenShot.as_ref() {
            try!(os.write_bytes(5, &v));
        };
        if let Some(v) = self.executionTime {
            try!(os.write_int64(6, v));
        };
        for v in self.message.iter() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.errorType {
            try!(os.write_enum(8, v as i32));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoExecutionResult>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoExecutionResult {
    fn new() -> ProtoExecutionResult {
        ProtoExecutionResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoExecutionResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "failed",
                    ProtoExecutionResult::has_failed,
                    ProtoExecutionResult::get_failed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "recoverableError",
                    ProtoExecutionResult::has_recoverableError,
                    ProtoExecutionResult::get_recoverableError,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "errorMessage",
                    ProtoExecutionResult::has_errorMessage,
                    ProtoExecutionResult::get_errorMessage,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "stackTrace",
                    ProtoExecutionResult::has_stackTrace,
                    ProtoExecutionResult::get_stackTrace,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "screenShot",
                    ProtoExecutionResult::has_screenShot,
                    ProtoExecutionResult::get_screenShot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "executionTime",
                    ProtoExecutionResult::has_executionTime,
                    ProtoExecutionResult::get_executionTime,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "message",
                    ProtoExecutionResult::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "errorType",
                    ProtoExecutionResult::has_errorType,
                    ProtoExecutionResult::get_errorType,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoExecutionResult>(
                    "ProtoExecutionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoExecutionResult {
    fn clear(&mut self) {
        self.clear_failed();
        self.clear_recoverableError();
        self.clear_errorMessage();
        self.clear_stackTrace();
        self.clear_screenShot();
        self.clear_executionTime();
        self.clear_message();
        self.clear_errorType();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoExecutionResult {
    fn eq(&self, other: &ProtoExecutionResult) -> bool {
        self.failed == other.failed &&
        self.recoverableError == other.recoverableError &&
        self.errorMessage == other.errorMessage &&
        self.stackTrace == other.stackTrace &&
        self.screenShot == other.screenShot &&
        self.executionTime == other.executionTime &&
        self.message == other.message &&
        self.errorType == other.errorType &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoExecutionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtoExecutionResult_ErrorType {
    ASSERTION = 1,
    VERIFICATION = 2,
}

impl ::protobuf::ProtobufEnum for ProtoExecutionResult_ErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoExecutionResult_ErrorType> {
        match value {
            1 => ::std::option::Option::Some(ProtoExecutionResult_ErrorType::ASSERTION),
            2 => ::std::option::Option::Some(ProtoExecutionResult_ErrorType::VERIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtoExecutionResult_ErrorType] = &[
            ProtoExecutionResult_ErrorType::ASSERTION,
            ProtoExecutionResult_ErrorType::VERIFICATION,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ProtoExecutionResult_ErrorType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ProtoExecutionResult_ErrorType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ProtoExecutionResult_ErrorType {
}

#[derive(Clone,Default)]
pub struct ProtoHookFailure {
    // message fields
    stackTrace: ::protobuf::SingularField<::std::string::String>,
    errorMessage: ::protobuf::SingularField<::std::string::String>,
    screenShot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoHookFailure {
    pub fn new() -> ProtoHookFailure {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoHookFailure {
        static mut instance: ::protobuf::lazy::Lazy<ProtoHookFailure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoHookFailure,
        };
        unsafe {
            instance.get(|| {
                ProtoHookFailure {
                    stackTrace: ::protobuf::SingularField::none(),
                    errorMessage: ::protobuf::SingularField::none(),
                    screenShot: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string stackTrace = 1;

    pub fn clear_stackTrace(&mut self) {
        self.stackTrace.clear();
    }

    pub fn has_stackTrace(&self) -> bool {
        self.stackTrace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stackTrace(&mut self, v: ::std::string::String) {
        self.stackTrace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stackTrace<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.stackTrace.is_none() {
            self.stackTrace.set_default();
        };
        self.stackTrace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stackTrace(&mut self) -> ::std::string::String {
        self.stackTrace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_stackTrace<'a>(&'a self) -> &'a str {
        match self.stackTrace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string errorMessage = 2;

    pub fn clear_errorMessage(&mut self) {
        self.errorMessage.clear();
    }

    pub fn has_errorMessage(&self) -> bool {
        self.errorMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.errorMessage.is_none() {
            self.errorMessage.set_default();
        };
        self.errorMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        self.errorMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_errorMessage<'a>(&'a self) -> &'a str {
        match self.errorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes screenShot = 3;

    pub fn clear_screenShot(&mut self) {
        self.screenShot.clear();
    }

    pub fn has_screenShot(&self) -> bool {
        self.screenShot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenShot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenShot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenShot<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.screenShot.is_none() {
            self.screenShot.set_default();
        };
        self.screenShot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenShot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenShot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_screenShot<'a>(&'a self) -> &'a [u8] {
        match self.screenShot.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ProtoHookFailure {
    fn is_initialized(&self) -> bool {
        if self.stackTrace.is_none() {
            return false;
        };
        if self.errorMessage.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stackTrace));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenShot));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stackTrace.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.errorMessage.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.screenShot.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stackTrace.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.errorMessage.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.screenShot.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoHookFailure>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoHookFailure {
    fn new() -> ProtoHookFailure {
        ProtoHookFailure::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoHookFailure>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "stackTrace",
                    ProtoHookFailure::has_stackTrace,
                    ProtoHookFailure::get_stackTrace,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "errorMessage",
                    ProtoHookFailure::has_errorMessage,
                    ProtoHookFailure::get_errorMessage,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "screenShot",
                    ProtoHookFailure::has_screenShot,
                    ProtoHookFailure::get_screenShot,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoHookFailure>(
                    "ProtoHookFailure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoHookFailure {
    fn clear(&mut self) {
        self.clear_stackTrace();
        self.clear_errorMessage();
        self.clear_screenShot();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoHookFailure {
    fn eq(&self, other: &ProtoHookFailure) -> bool {
        self.stackTrace == other.stackTrace &&
        self.errorMessage == other.errorMessage &&
        self.screenShot == other.screenShot &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoHookFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoSuiteResult {
    // message fields
    specResults: ::protobuf::RepeatedField<ProtoSpecResult>,
    preHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    postHookFailure: ::protobuf::SingularPtrField<ProtoHookFailure>,
    failed: ::std::option::Option<bool>,
    specsFailedCount: ::std::option::Option<i32>,
    executionTime: ::std::option::Option<i64>,
    successRate: ::std::option::Option<f32>,
    environment: ::protobuf::SingularField<::std::string::String>,
    tags: ::protobuf::SingularField<::std::string::String>,
    projectName: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::protobuf::SingularField<::std::string::String>,
    specsSkippedCount: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoSuiteResult {
    pub fn new() -> ProtoSuiteResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoSuiteResult {
        static mut instance: ::protobuf::lazy::Lazy<ProtoSuiteResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoSuiteResult,
        };
        unsafe {
            instance.get(|| {
                ProtoSuiteResult {
                    specResults: ::protobuf::RepeatedField::new(),
                    preHookFailure: ::protobuf::SingularPtrField::none(),
                    postHookFailure: ::protobuf::SingularPtrField::none(),
                    failed: ::std::option::Option::None,
                    specsFailedCount: ::std::option::Option::None,
                    executionTime: ::std::option::Option::None,
                    successRate: ::std::option::Option::None,
                    environment: ::protobuf::SingularField::none(),
                    tags: ::protobuf::SingularField::none(),
                    projectName: ::protobuf::SingularField::none(),
                    timestamp: ::protobuf::SingularField::none(),
                    specsSkippedCount: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .gauge.messages.ProtoSpecResult specResults = 1;

    pub fn clear_specResults(&mut self) {
        self.specResults.clear();
    }

    // Param is passed by value, moved
    pub fn set_specResults(&mut self, v: ::protobuf::RepeatedField<ProtoSpecResult>) {
        self.specResults = v;
    }

    // Mutable pointer to the field.
    pub fn mut_specResults<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ProtoSpecResult> {
        &mut self.specResults
    }

    // Take field
    pub fn take_specResults(&mut self) -> ::protobuf::RepeatedField<ProtoSpecResult> {
        ::std::mem::replace(&mut self.specResults, ::protobuf::RepeatedField::new())
    }

    pub fn get_specResults<'a>(&'a self) -> &'a [ProtoSpecResult] {
        &self.specResults
    }

    // optional .gauge.messages.ProtoHookFailure preHookFailure = 2;

    pub fn clear_preHookFailure(&mut self) {
        self.preHookFailure.clear();
    }

    pub fn has_preHookFailure(&self) -> bool {
        self.preHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preHookFailure(&mut self, v: ProtoHookFailure) {
        self.preHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.preHookFailure.is_none() {
            self.preHookFailure.set_default();
        };
        self.preHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_preHookFailure(&mut self) -> ProtoHookFailure {
        self.preHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_preHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.preHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // optional .gauge.messages.ProtoHookFailure postHookFailure = 3;

    pub fn clear_postHookFailure(&mut self) {
        self.postHookFailure.clear();
    }

    pub fn has_postHookFailure(&self) -> bool {
        self.postHookFailure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postHookFailure(&mut self, v: ProtoHookFailure) {
        self.postHookFailure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postHookFailure<'a>(&'a mut self) -> &'a mut ProtoHookFailure {
        if self.postHookFailure.is_none() {
            self.postHookFailure.set_default();
        };
        self.postHookFailure.as_mut().unwrap()
    }

    // Take field
    pub fn take_postHookFailure(&mut self) -> ProtoHookFailure {
        self.postHookFailure.take().unwrap_or_else(|| ProtoHookFailure::new())
    }

    pub fn get_postHookFailure<'a>(&'a self) -> &'a ProtoHookFailure {
        self.postHookFailure.as_ref().unwrap_or_else(|| ProtoHookFailure::default_instance())
    }

    // required bool failed = 4;

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    pub fn get_failed<'a>(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    // required int32 specsFailedCount = 5;

    pub fn clear_specsFailedCount(&mut self) {
        self.specsFailedCount = ::std::option::Option::None;
    }

    pub fn has_specsFailedCount(&self) -> bool {
        self.specsFailedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specsFailedCount(&mut self, v: i32) {
        self.specsFailedCount = ::std::option::Option::Some(v);
    }

    pub fn get_specsFailedCount<'a>(&self) -> i32 {
        self.specsFailedCount.unwrap_or(0)
    }

    // optional int64 executionTime = 6;

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    pub fn get_executionTime<'a>(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    // required float successRate = 7;

    pub fn clear_successRate(&mut self) {
        self.successRate = ::std::option::Option::None;
    }

    pub fn has_successRate(&self) -> bool {
        self.successRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successRate(&mut self, v: f32) {
        self.successRate = ::std::option::Option::Some(v);
    }

    pub fn get_successRate<'a>(&self) -> f32 {
        self.successRate.unwrap_or(0.)
    }

    // optional string environment = 8;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::string::String) {
        self.environment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.environment.is_none() {
            self.environment.set_default();
        };
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::string::String {
        self.environment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_environment<'a>(&'a self) -> &'a str {
        match self.environment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tags = 9;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.tags.is_none() {
            self.tags.set_default();
        };
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_tags<'a>(&'a self) -> &'a str {
        match self.tags.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string projectName = 10;

    pub fn clear_projectName(&mut self) {
        self.projectName.clear();
    }

    pub fn has_projectName(&self) -> bool {
        self.projectName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectName(&mut self, v: ::std::string::String) {
        self.projectName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_projectName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.projectName.is_none() {
            self.projectName.set_default();
        };
        self.projectName.as_mut().unwrap()
    }

    // Take field
    pub fn take_projectName(&mut self) -> ::std::string::String {
        self.projectName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_projectName<'a>(&'a self) -> &'a str {
        match self.projectName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string timestamp = 11;

    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.timestamp.is_none() {
            self.timestamp.set_default();
        };
        self.timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        self.timestamp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_timestamp<'a>(&'a self) -> &'a str {
        match self.timestamp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required int32 specsSkippedCount = 12;

    pub fn clear_specsSkippedCount(&mut self) {
        self.specsSkippedCount = ::std::option::Option::None;
    }

    pub fn has_specsSkippedCount(&self) -> bool {
        self.specsSkippedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specsSkippedCount(&mut self, v: i32) {
        self.specsSkippedCount = ::std::option::Option::Some(v);
    }

    pub fn get_specsSkippedCount<'a>(&self) -> i32 {
        self.specsSkippedCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for ProtoSuiteResult {
    fn is_initialized(&self) -> bool {
        if self.failed.is_none() {
            return false;
        };
        if self.specsFailedCount.is_none() {
            return false;
        };
        if self.successRate.is_none() {
            return false;
        };
        if self.projectName.is_none() {
            return false;
        };
        if self.timestamp.is_none() {
            return false;
        };
        if self.specsSkippedCount.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.specResults));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preHookFailure));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postHookFailure));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.failed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.specsFailedCount = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.executionTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.successRate = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.environment));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tags));
                },
                10 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.projectName));
                },
                11 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.timestamp));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.specsSkippedCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.specResults.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.preHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.postHookFailure.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.failed.is_some() {
            my_size += 2;
        };
        for value in self.specsFailedCount.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.executionTime.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.successRate.is_some() {
            my_size += 5;
        };
        for value in self.environment.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.tags.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.projectName.iter() {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in self.timestamp.iter() {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in self.specsSkippedCount.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.specResults.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.postHookFailure.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.failed {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.specsFailedCount {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.executionTime {
            try!(os.write_int64(6, v));
        };
        if let Some(v) = self.successRate {
            try!(os.write_float(7, v));
        };
        if let Some(v) = self.environment.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.tags.as_ref() {
            try!(os.write_string(9, &v));
        };
        if let Some(v) = self.projectName.as_ref() {
            try!(os.write_string(10, &v));
        };
        if let Some(v) = self.timestamp.as_ref() {
            try!(os.write_string(11, &v));
        };
        if let Some(v) = self.specsSkippedCount {
            try!(os.write_int32(12, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoSuiteResult>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoSuiteResult {
    fn new() -> ProtoSuiteResult {
        ProtoSuiteResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoSuiteResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "specResults",
                    ProtoSuiteResult::get_specResults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "preHookFailure",
                    ProtoSuiteResult::has_preHookFailure,
                    ProtoSuiteResult::get_preHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "postHookFailure",
                    ProtoSuiteResult::has_postHookFailure,
                    ProtoSuiteResult::get_postHookFailure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "failed",
                    ProtoSuiteResult::has_failed,
                    ProtoSuiteResult::get_failed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "specsFailedCount",
                    ProtoSuiteResult::has_specsFailedCount,
                    ProtoSuiteResult::get_specsFailedCount,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "executionTime",
                    ProtoSuiteResult::has_executionTime,
                    ProtoSuiteResult::get_executionTime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "successRate",
                    ProtoSuiteResult::has_successRate,
                    ProtoSuiteResult::get_successRate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "environment",
                    ProtoSuiteResult::has_environment,
                    ProtoSuiteResult::get_environment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "tags",
                    ProtoSuiteResult::has_tags,
                    ProtoSuiteResult::get_tags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "projectName",
                    ProtoSuiteResult::has_projectName,
                    ProtoSuiteResult::get_projectName,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "timestamp",
                    ProtoSuiteResult::has_timestamp,
                    ProtoSuiteResult::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "specsSkippedCount",
                    ProtoSuiteResult::has_specsSkippedCount,
                    ProtoSuiteResult::get_specsSkippedCount,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoSuiteResult>(
                    "ProtoSuiteResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoSuiteResult {
    fn clear(&mut self) {
        self.clear_specResults();
        self.clear_preHookFailure();
        self.clear_postHookFailure();
        self.clear_failed();
        self.clear_specsFailedCount();
        self.clear_executionTime();
        self.clear_successRate();
        self.clear_environment();
        self.clear_tags();
        self.clear_projectName();
        self.clear_timestamp();
        self.clear_specsSkippedCount();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoSuiteResult {
    fn eq(&self, other: &ProtoSuiteResult) -> bool {
        self.specResults == other.specResults &&
        self.preHookFailure == other.preHookFailure &&
        self.postHookFailure == other.postHookFailure &&
        self.failed == other.failed &&
        self.specsFailedCount == other.specsFailedCount &&
        self.executionTime == other.executionTime &&
        self.successRate == other.successRate &&
        self.environment == other.environment &&
        self.tags == other.tags &&
        self.projectName == other.projectName &&
        self.timestamp == other.timestamp &&
        self.specsSkippedCount == other.specsSkippedCount &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoSuiteResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoSpecResult {
    // message fields
    protoSpec: ::protobuf::SingularPtrField<ProtoSpec>,
    scenarioCount: ::std::option::Option<i32>,
    scenarioFailedCount: ::std::option::Option<i32>,
    failed: ::std::option::Option<bool>,
    failedDataTableRows: ::std::vec::Vec<i32>,
    executionTime: ::std::option::Option<i64>,
    skipped: ::std::option::Option<bool>,
    scenarioSkippedCount: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoSpecResult {
    pub fn new() -> ProtoSpecResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoSpecResult {
        static mut instance: ::protobuf::lazy::Lazy<ProtoSpecResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoSpecResult,
        };
        unsafe {
            instance.get(|| {
                ProtoSpecResult {
                    protoSpec: ::protobuf::SingularPtrField::none(),
                    scenarioCount: ::std::option::Option::None,
                    scenarioFailedCount: ::std::option::Option::None,
                    failed: ::std::option::Option::None,
                    failedDataTableRows: ::std::vec::Vec::new(),
                    executionTime: ::std::option::Option::None,
                    skipped: ::std::option::Option::None,
                    scenarioSkippedCount: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .gauge.messages.ProtoSpec protoSpec = 1;

    pub fn clear_protoSpec(&mut self) {
        self.protoSpec.clear();
    }

    pub fn has_protoSpec(&self) -> bool {
        self.protoSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protoSpec(&mut self, v: ProtoSpec) {
        self.protoSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protoSpec<'a>(&'a mut self) -> &'a mut ProtoSpec {
        if self.protoSpec.is_none() {
            self.protoSpec.set_default();
        };
        self.protoSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_protoSpec(&mut self) -> ProtoSpec {
        self.protoSpec.take().unwrap_or_else(|| ProtoSpec::new())
    }

    pub fn get_protoSpec<'a>(&'a self) -> &'a ProtoSpec {
        self.protoSpec.as_ref().unwrap_or_else(|| ProtoSpec::default_instance())
    }

    // required int32 scenarioCount = 2;

    pub fn clear_scenarioCount(&mut self) {
        self.scenarioCount = ::std::option::Option::None;
    }

    pub fn has_scenarioCount(&self) -> bool {
        self.scenarioCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioCount(&mut self, v: i32) {
        self.scenarioCount = ::std::option::Option::Some(v);
    }

    pub fn get_scenarioCount<'a>(&self) -> i32 {
        self.scenarioCount.unwrap_or(0)
    }

    // required int32 scenarioFailedCount = 3;

    pub fn clear_scenarioFailedCount(&mut self) {
        self.scenarioFailedCount = ::std::option::Option::None;
    }

    pub fn has_scenarioFailedCount(&self) -> bool {
        self.scenarioFailedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioFailedCount(&mut self, v: i32) {
        self.scenarioFailedCount = ::std::option::Option::Some(v);
    }

    pub fn get_scenarioFailedCount<'a>(&self) -> i32 {
        self.scenarioFailedCount.unwrap_or(0)
    }

    // required bool failed = 4;

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    pub fn get_failed<'a>(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    // repeated int32 failedDataTableRows = 5;

    pub fn clear_failedDataTableRows(&mut self) {
        self.failedDataTableRows.clear();
    }

    // Param is passed by value, moved
    pub fn set_failedDataTableRows(&mut self, v: ::std::vec::Vec<i32>) {
        self.failedDataTableRows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failedDataTableRows<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.failedDataTableRows
    }

    // Take field
    pub fn take_failedDataTableRows(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.failedDataTableRows, ::std::vec::Vec::new())
    }

    pub fn get_failedDataTableRows<'a>(&'a self) -> &'a [i32] {
        &self.failedDataTableRows
    }

    // optional int64 executionTime = 6;

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    pub fn get_executionTime<'a>(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    // required bool skipped = 7;

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: bool) {
        self.skipped = ::std::option::Option::Some(v);
    }

    pub fn get_skipped<'a>(&self) -> bool {
        self.skipped.unwrap_or(false)
    }

    // required int32 scenarioSkippedCount = 9;

    pub fn clear_scenarioSkippedCount(&mut self) {
        self.scenarioSkippedCount = ::std::option::Option::None;
    }

    pub fn has_scenarioSkippedCount(&self) -> bool {
        self.scenarioSkippedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioSkippedCount(&mut self, v: i32) {
        self.scenarioSkippedCount = ::std::option::Option::Some(v);
    }

    pub fn get_scenarioSkippedCount<'a>(&self) -> i32 {
        self.scenarioSkippedCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for ProtoSpecResult {
    fn is_initialized(&self) -> bool {
        if self.protoSpec.is_none() {
            return false;
        };
        if self.scenarioCount.is_none() {
            return false;
        };
        if self.scenarioFailedCount.is_none() {
            return false;
        };
        if self.failed.is_none() {
            return false;
        };
        if self.skipped.is_none() {
            return false;
        };
        if self.scenarioSkippedCount.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protoSpec));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.scenarioCount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.scenarioFailedCount = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.failed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.failedDataTableRows));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.executionTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.skipped = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.scenarioSkippedCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.protoSpec.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.scenarioCount.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.scenarioFailedCount.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.failed.is_some() {
            my_size += 2;
        };
        for value in self.failedDataTableRows.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.executionTime.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.skipped.is_some() {
            my_size += 2;
        };
        for value in self.scenarioSkippedCount.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protoSpec.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.scenarioCount {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.scenarioFailedCount {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.failed {
            try!(os.write_bool(4, v));
        };
        for v in self.failedDataTableRows.iter() {
            try!(os.write_int32(5, *v));
        };
        if let Some(v) = self.executionTime {
            try!(os.write_int64(6, v));
        };
        if let Some(v) = self.skipped {
            try!(os.write_bool(7, v));
        };
        if let Some(v) = self.scenarioSkippedCount {
            try!(os.write_int32(9, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoSpecResult>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoSpecResult {
    fn new() -> ProtoSpecResult {
        ProtoSpecResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoSpecResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "protoSpec",
                    ProtoSpecResult::has_protoSpec,
                    ProtoSpecResult::get_protoSpec,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "scenarioCount",
                    ProtoSpecResult::has_scenarioCount,
                    ProtoSpecResult::get_scenarioCount,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "scenarioFailedCount",
                    ProtoSpecResult::has_scenarioFailedCount,
                    ProtoSpecResult::get_scenarioFailedCount,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "failed",
                    ProtoSpecResult::has_failed,
                    ProtoSpecResult::get_failed,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_i32_accessor(
                    "failedDataTableRows",
                    ProtoSpecResult::get_failedDataTableRows,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "executionTime",
                    ProtoSpecResult::has_executionTime,
                    ProtoSpecResult::get_executionTime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "skipped",
                    ProtoSpecResult::has_skipped,
                    ProtoSpecResult::get_skipped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "scenarioSkippedCount",
                    ProtoSpecResult::has_scenarioSkippedCount,
                    ProtoSpecResult::get_scenarioSkippedCount,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoSpecResult>(
                    "ProtoSpecResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoSpecResult {
    fn clear(&mut self) {
        self.clear_protoSpec();
        self.clear_scenarioCount();
        self.clear_scenarioFailedCount();
        self.clear_failed();
        self.clear_failedDataTableRows();
        self.clear_executionTime();
        self.clear_skipped();
        self.clear_scenarioSkippedCount();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoSpecResult {
    fn eq(&self, other: &ProtoSpecResult) -> bool {
        self.protoSpec == other.protoSpec &&
        self.scenarioCount == other.scenarioCount &&
        self.scenarioFailedCount == other.scenarioFailedCount &&
        self.failed == other.failed &&
        self.failedDataTableRows == other.failedDataTableRows &&
        self.executionTime == other.executionTime &&
        self.skipped == other.skipped &&
        self.scenarioSkippedCount == other.scenarioSkippedCount &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoSpecResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ProtoStepValue {
    // message fields
    stepValue: ::protobuf::SingularField<::std::string::String>,
    parameterizedStepValue: ::protobuf::SingularField<::std::string::String>,
    parameters: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl ProtoStepValue {
    pub fn new() -> ProtoStepValue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoStepValue {
        static mut instance: ::protobuf::lazy::Lazy<ProtoStepValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoStepValue,
        };
        unsafe {
            instance.get(|| {
                ProtoStepValue {
                    stepValue: ::protobuf::SingularField::none(),
                    parameterizedStepValue: ::protobuf::SingularField::none(),
                    parameters: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string stepValue = 1;

    pub fn clear_stepValue(&mut self) {
        self.stepValue.clear();
    }

    pub fn has_stepValue(&self) -> bool {
        self.stepValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepValue(&mut self, v: ::std::string::String) {
        self.stepValue = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stepValue<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.stepValue.is_none() {
            self.stepValue.set_default();
        };
        self.stepValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_stepValue(&mut self) -> ::std::string::String {
        self.stepValue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_stepValue<'a>(&'a self) -> &'a str {
        match self.stepValue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string parameterizedStepValue = 2;

    pub fn clear_parameterizedStepValue(&mut self) {
        self.parameterizedStepValue.clear();
    }

    pub fn has_parameterizedStepValue(&self) -> bool {
        self.parameterizedStepValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterizedStepValue(&mut self, v: ::std::string::String) {
        self.parameterizedStepValue = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameterizedStepValue<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.parameterizedStepValue.is_none() {
            self.parameterizedStepValue.set_default();
        };
        self.parameterizedStepValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameterizedStepValue(&mut self) -> ::std::string::String {
        self.parameterizedStepValue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_parameterizedStepValue<'a>(&'a self) -> &'a str {
        match self.parameterizedStepValue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string parameters = 3;

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameters<'a>(&'a self) -> &'a [::std::string::String] {
        &self.parameters
    }
}

impl ::protobuf::Message for ProtoStepValue {
    fn is_initialized(&self) -> bool {
        if self.stepValue.is_none() {
            return false;
        };
        if self.parameterizedStepValue.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stepValue));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parameterizedStepValue));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.parameters));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stepValue.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.parameterizedStepValue.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.parameters.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepValue.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.parameterizedStepValue.as_ref() {
            try!(os.write_string(2, &v));
        };
        for v in self.parameters.iter() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ProtoStepValue>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoStepValue {
    fn new() -> ProtoStepValue {
        ProtoStepValue::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoStepValue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "stepValue",
                    ProtoStepValue::has_stepValue,
                    ProtoStepValue::get_stepValue,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "parameterizedStepValue",
                    ProtoStepValue::has_parameterizedStepValue,
                    ProtoStepValue::get_parameterizedStepValue,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "parameters",
                    ProtoStepValue::get_parameters,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoStepValue>(
                    "ProtoStepValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoStepValue {
    fn clear(&mut self) {
        self.clear_stepValue();
        self.clear_parameterizedStepValue();
        self.clear_parameters();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ProtoStepValue {
    fn eq(&self, other: &ProtoStepValue) -> bool {
        self.stepValue == other.stepValue &&
        self.parameterizedStepValue == other.parameterizedStepValue &&
        self.parameters == other.parameters &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ProtoStepValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x0a, 0x73, 0x70, 0x65, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x67, 0x61,
    0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x22, 0xf6, 0x01, 0x0a,
    0x09, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x70, 0x65, 0x63, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x70,
    0x65, 0x63, 0x48, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x28, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19,
    0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x15, 0x0a, 0x0d, 0x69, 0x73, 0x54,
    0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x02, 0x28, 0x08,
    0x12, 0x38, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75,
    0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65,
    0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48,
    0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x0f, 0x70, 0x6f,
    0x73, 0x74, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18, 0x05, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61,
    0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d,
    0x65, 0x18, 0x06, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18,
    0x07, 0x20, 0x03, 0x28, 0x09, 0x22, 0x80, 0x04, 0x0a, 0x09, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49,
    0x74, 0x65, 0x6d, 0x12, 0x34, 0x0a, 0x08, 0x69, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x22, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74, 0x65, 0x6d,
    0x2e, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12, 0x27, 0x0a, 0x04, 0x73, 0x74, 0x65,
    0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74,
    0x65, 0x70, 0x12, 0x2d, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x43, 0x6f, 0x6e, 0x63, 0x65, 0x70,
    0x74, 0x12, 0x2f, 0x0a, 0x08, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72,
    0x69, 0x6f, 0x12, 0x45, 0x0a, 0x13, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65,
    0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x28, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73,
    0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65,
    0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x12, 0x2d, 0x0a, 0x07, 0x63, 0x6f, 0x6d,
    0x6d, 0x65, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x61, 0x75,
    0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x29, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c,
    0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61,
    0x62, 0x6c, 0x65, 0x12, 0x27, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x67, 0x73, 0x22, 0x6a, 0x0a, 0x08,
    0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x74, 0x65, 0x70,
    0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x10, 0x02, 0x12,
    0x0b, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x10, 0x03, 0x12, 0x0c, 0x0a, 0x08,
    0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x10, 0x04, 0x12, 0x17, 0x0a, 0x13, 0x54, 0x61,
    0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69,
    0x6f, 0x10, 0x05, 0x12, 0x09, 0x0a, 0x05, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x10, 0x06, 0x12, 0x08,
    0x0a, 0x04, 0x54, 0x61, 0x67, 0x73, 0x10, 0x07, 0x22, 0x94, 0x03, 0x0a, 0x0d, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x63,
    0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x48, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x02, 0x20,
    0x02, 0x28, 0x08, 0x12, 0x2b, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x73, 0x18,
    0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74, 0x65, 0x6d,
    0x12, 0x30, 0x0a, 0x0d, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x49, 0x74, 0x65, 0x6d,
    0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74,
    0x65, 0x6d, 0x12, 0x38, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69,
    0x6c, 0x75, 0x72, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x67, 0x61, 0x75,
    0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x0f,
    0x70, 0x6f, 0x73, 0x74, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18,
    0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b,
    0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18,
    0x07, 0x20, 0x03, 0x28, 0x09, 0x12, 0x15, 0x0a, 0x0d, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
    0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07,
    0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64, 0x18, 0x09, 0x20, 0x02, 0x28, 0x08, 0x12, 0x12, 0x0a,
    0x0a, 0x73, 0x6b, 0x69, 0x70, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28,
    0x09, 0x12, 0x0a, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x12, 0x30, 0x0a,
    0x0d, 0x74, 0x65, 0x61, 0x72, 0x44, 0x6f, 0x77, 0x6e, 0x53, 0x74, 0x65, 0x70, 0x73, 0x18, 0x0c,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74, 0x65, 0x6d, 0x22,
    0x4c, 0x0a, 0x18, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69,
    0x76, 0x65, 0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x12, 0x30, 0x0a, 0x09, 0x73,
    0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d,
    0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x22, 0xa7, 0x01,
    0x0a, 0x09, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74, 0x65, 0x70, 0x12, 0x12, 0x0a, 0x0a, 0x61,
    0x63, 0x74, 0x75, 0x61, 0x6c, 0x54, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x12, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x54, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20,
    0x02, 0x28, 0x09, 0x12, 0x2b, 0x0a, 0x09, 0x66, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73,
    0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74,
    0x12, 0x45, 0x0a, 0x13, 0x73, 0x74, 0x65, 0x70, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f,
    0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e,
    0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74, 0x65, 0x70, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f,
    0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x22, 0xb2, 0x01, 0x0a, 0x0c, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x43, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x12, 0x2e, 0x0a, 0x0b, 0x63, 0x6f, 0x6e, 0x63,
    0x65, 0x70, 0x74, 0x53, 0x74, 0x65, 0x70, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x19, 0x2e,
    0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74, 0x65, 0x70, 0x12, 0x28, 0x0a, 0x05, 0x73, 0x74, 0x65, 0x70,
    0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74,
    0x65, 0x6d, 0x12, 0x48, 0x0a, 0x16, 0x63, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x45, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x28, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74, 0x65, 0x70, 0x45, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x22, 0x19, 0x0a, 0x09,
    0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x67, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x61, 0x67,
    0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x22, 0xac, 0x01, 0x0a, 0x08, 0x46, 0x72, 0x61, 0x67,
    0x6d, 0x65, 0x6e, 0x74, 0x12, 0x3b, 0x0a, 0x0c, 0x66, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74,
    0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x25, 0x2e, 0x67, 0x61, 0x75,
    0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x46, 0x72, 0x61, 0x67,
    0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70,
    0x65, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x2c, 0x0a, 0x09, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x27, 0x0a,
    0x0c, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a,
    0x04, 0x54, 0x65, 0x78, 0x74, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x50, 0x61, 0x72, 0x61, 0x6d,
    0x65, 0x74, 0x65, 0x72, 0x10, 0x02, 0x22, 0xef, 0x01, 0x0a, 0x09, 0x50, 0x61, 0x72, 0x61, 0x6d,
    0x65, 0x74, 0x65, 0x72, 0x12, 0x3e, 0x0a, 0x0d, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
    0x72, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x67, 0x61,
    0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x61, 0x72,
    0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
    0x54, 0x79, 0x70, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x29, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x1a, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x22, 0x5a, 0x0a, 0x0d,
    0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0a, 0x0a,
    0x06, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x44, 0x79, 0x6e,
    0x61, 0x6d, 0x69, 0x63, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61,
    0x6c, 0x5f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x10, 0x03, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x70,
    0x65, 0x63, 0x69, 0x61, 0x6c, 0x5f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x10, 0x04, 0x12, 0x09, 0x0a,
    0x05, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x10, 0x05, 0x22, 0x1c, 0x0a, 0x0c, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x69, 0x0a, 0x0a, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54,
    0x61, 0x62, 0x6c, 0x65, 0x12, 0x2e, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x62, 0x6c,
    0x65, 0x52, 0x6f, 0x77, 0x12, 0x2b, 0x0a, 0x04, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x02, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f,
    0x77, 0x22, 0x1e, 0x0a, 0x0d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x52,
    0x6f, 0x77, 0x12, 0x0d, 0x0a, 0x05, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
    0x09, 0x22, 0xf6, 0x01, 0x0a, 0x18, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x74, 0x65, 0x70, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x3d,
    0x0a, 0x0f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x45, 0x78,
    0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x38, 0x0a,
    0x0e, 0x70, 0x72, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b,
    0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x0f, 0x70, 0x6f, 0x73, 0x74, 0x48,
    0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75,
    0x72, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64, 0x18, 0x04, 0x20,
    0x02, 0x28, 0x08, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64, 0x52, 0x65,
    0x61, 0x73, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x22, 0xa2, 0x02, 0x0a, 0x14, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x08, 0x12, 0x18, 0x0a, 0x10, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x62,
    0x6c, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x14, 0x0a,
    0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x63, 0x6b, 0x54, 0x72, 0x61, 0x63,
    0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x63, 0x72, 0x65, 0x65,
    0x6e, 0x53, 0x68, 0x6f, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x15, 0x0a, 0x0d, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x02,
    0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x07, 0x20,
    0x03, 0x28, 0x09, 0x12, 0x4c, 0x0a, 0x09, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65,
    0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x45, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x2e, 0x45, 0x72, 0x72,
    0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x09, 0x41, 0x53, 0x53, 0x45, 0x52, 0x54, 0x49, 0x4f,
    0x4e, 0x22, 0x2c, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0d,
    0x0a, 0x09, 0x41, 0x53, 0x53, 0x45, 0x52, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x01, 0x12, 0x10, 0x0a,
    0x0c, 0x56, 0x45, 0x52, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x02, 0x22,
    0x50, 0x0a, 0x10, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c,
    0x75, 0x72, 0x65, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x63, 0x6b, 0x54, 0x72, 0x61, 0x63,
    0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72,
    0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a,
    0x0a, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x53, 0x68, 0x6f, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0c, 0x22, 0xf9, 0x02, 0x0a, 0x10, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x75, 0x69, 0x74, 0x65,
    0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x34, 0x0a, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x52, 0x65,
    0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x67, 0x61,
    0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x53, 0x70, 0x65, 0x63, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x38, 0x0a, 0x0e,
    0x70, 0x72, 0x65, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b, 0x46,
    0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x39, 0x0a, 0x0f, 0x70, 0x6f, 0x73, 0x74, 0x48, 0x6f,
    0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x20, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73,
    0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x6f, 0x6f, 0x6b, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72,
    0x65, 0x12, 0x0e, 0x0a, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20, 0x02, 0x28,
    0x08, 0x12, 0x18, 0x0a, 0x10, 0x73, 0x70, 0x65, 0x63, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64,
    0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x02, 0x28, 0x05, 0x12, 0x15, 0x0a, 0x0d, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x52, 0x61, 0x74,
    0x65, 0x18, 0x07, 0x20, 0x02, 0x28, 0x02, 0x12, 0x13, 0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72,
    0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04,
    0x74, 0x61, 0x67, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x72,
    0x6f, 0x6a, 0x65, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x0a, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0b, 0x20, 0x02,
    0x28, 0x09, 0x12, 0x19, 0x0a, 0x11, 0x73, 0x70, 0x65, 0x63, 0x73, 0x53, 0x6b, 0x69, 0x70, 0x70,
    0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x0c, 0x20, 0x02, 0x28, 0x05, 0x22, 0xe6, 0x01,
    0x0a, 0x0f, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x70, 0x65, 0x63, 0x52, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x12, 0x2c, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x70, 0x65, 0x63, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x61, 0x75, 0x67, 0x65, 0x2e, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53, 0x70, 0x65, 0x63, 0x12,
    0x15, 0x0a, 0x0d, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x43, 0x6f, 0x75, 0x6e, 0x74,
    0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x12, 0x1b, 0x0a, 0x13, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72,
    0x69, 0x6f, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20,
    0x02, 0x28, 0x05, 0x12, 0x0e, 0x0a, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20,
    0x02, 0x28, 0x08, 0x12, 0x1b, 0x0a, 0x13, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x44, 0x61, 0x74,
    0x61, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x77, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x05,
    0x12, 0x15, 0x0a, 0x0d, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x6b, 0x69, 0x70, 0x70,
    0x65, 0x64, 0x18, 0x07, 0x20, 0x02, 0x28, 0x08, 0x12, 0x1c, 0x0a, 0x14, 0x73, 0x63, 0x65, 0x6e,
    0x61, 0x72, 0x69, 0x6f, 0x53, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74,
    0x18, 0x09, 0x20, 0x02, 0x28, 0x05, 0x22, 0x57, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x53,
    0x74, 0x65, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x11, 0x0a, 0x09, 0x73, 0x74, 0x65, 0x70,
    0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x1e, 0x0a, 0x16, 0x70,
    0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x53, 0x74, 0x65, 0x70,
    0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x70,
    0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x4a,
    0x96, 0x73, 0x0a, 0x07, 0x12, 0x05, 0x10, 0x00, 0xa5, 0x02, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x02,
    0x12, 0x03, 0x11, 0x08, 0x16, 0x0a, 0x7d, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x18, 0x00, 0x27,
    0x01, 0x1a, 0x71, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a,
    0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x61, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x0a, 0x2f, 0x20, 0x41, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x53,
    0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x53, 0x74, 0x65, 0x70,
    0x73, 0x2c, 0x20, 0x62, 0x65, 0x73, 0x69, 0x64, 0x65, 0x73, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65,
    0x6e, 0x74, 0x73, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x18, 0x08, 0x11,
    0x0a, 0x34, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x1a, 0x04, 0x24, 0x1a, 0x27, 0x2f,
    0x20, 0x48, 0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62,
    0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x03, 0x1a, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x1a,
    0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1a, 0x14, 0x1f,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x1a, 0x22, 0x23, 0x0a, 0x3f,
    0x0a, 0x04, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x1c, 0x04, 0x21, 0x1a, 0x32, 0x2f, 0x20, 0x41,
    0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x69,
    0x74, 0x65, 0x6d, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x75,
    0x6e, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x74, 0x65, 0x70, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x04, 0x12, 0x03, 0x1c, 0x04, 0x0c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x01, 0x06, 0x12, 0x03, 0x1c, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x1c, 0x17, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x01, 0x03, 0x12, 0x03, 0x1c, 0x1f, 0x20, 0x0a, 0x9e, 0x01, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x02,
    0x12, 0x03, 0x1e, 0x04, 0x24, 0x1a, 0x90, 0x01, 0x2f, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x20, 0x69,
    0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x44, 0x72, 0x69,
    0x76, 0x65, 0x6e, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x20,
    0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x75,
    0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x72,
    0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02,
    0x04, 0x12, 0x03, 0x1e, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x05, 0x12,
    0x03, 0x1e, 0x0d, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x1e,
    0x12, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x03, 0x12, 0x03, 0x1e, 0x22, 0x23,
    0x0a, 0x70, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x03, 0x12, 0x03, 0x20, 0x04, 0x31, 0x1a, 0x63, 0x2f,
    0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61, 0x20, 0x27, 0x62, 0x65, 0x66,
    0x6f, 0x72, 0x65, 0x27, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x60, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x60, 0x20, 0x68,
    0x6f, 0x6f, 0x6b, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72,
    0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x04, 0x12, 0x03, 0x20, 0x04, 0x0c,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x06, 0x12, 0x03, 0x20, 0x0d, 0x1d, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x20, 0x1e, 0x2c, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x03, 0x03, 0x12, 0x03, 0x20, 0x2f, 0x30, 0x0a, 0x6f, 0x0a, 0x04, 0x04, 0x00,
    0x02, 0x04, 0x12, 0x03, 0x22, 0x04, 0x32, 0x1a, 0x62, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x73, 0x20, 0x61, 0x20, 0x27, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x27, 0x20, 0x68,
    0x6f, 0x6f, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e,
    0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x61, 0x66, 0x74, 0x65,
    0x72, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x60, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x68, 0x61, 0x73,
    0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x04, 0x04, 0x12, 0x03, 0x22, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x04, 0x06, 0x12, 0x03, 0x22, 0x0d, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x01,
    0x12, 0x03, 0x22, 0x1e, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x04, 0x03, 0x12, 0x03,
    0x22, 0x30, 0x31, 0x0a, 0x48, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x05, 0x12, 0x03, 0x24, 0x04, 0x21,
    0x1a, 0x3b, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x68, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x70,
    0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x05, 0x04, 0x12, 0x03, 0x24, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x05, 0x05, 0x12, 0x03, 0x24, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x03, 0x24, 0x14, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x05, 0x03,
    0x12, 0x03, 0x24, 0x1f, 0x20, 0x0a, 0x78, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x06, 0x12, 0x03, 0x26,
    0x04, 0x1d, 0x1a, 0x6b, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61,
    0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x61, 0x67, 0x73, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x61,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x2e, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61,
    0x72, 0x69, 0x6f, 0x20, 0x74, 0x61, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x68, 0x65, 0x72, 0x65, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x06, 0x04, 0x12, 0x03, 0x26, 0x04, 0x0c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x06, 0x05, 0x12, 0x03, 0x26, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x26, 0x14, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x06, 0x03, 0x12, 0x03, 0x26, 0x1b, 0x1c, 0x0a, 0x43, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x2b,
    0x00, 0x46, 0x01, 0x1a, 0x37, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x49,
    0x74, 0x65, 0x6d, 0x73, 0x20, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x61, 0x20, 0x53, 0x70, 0x65,
    0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03,
    0x04, 0x01, 0x01, 0x12, 0x03, 0x2b, 0x08, 0x11, 0x0a, 0xa4, 0x01, 0x0a, 0x04, 0x04, 0x01, 0x04,
    0x00, 0x12, 0x04, 0x2d, 0x04, 0x35, 0x05, 0x1a, 0x95, 0x01, 0x2f, 0x20, 0x45, 0x6e, 0x75, 0x6d,
    0x65, 0x72, 0x61, 0x74, 0x65, 0x73, 0x20, 0x76, 0x61, 0x72, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x69,
    0x74, 0x65, 0x6d, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x69, 0x74, 0x65, 0x6d, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x56, 0x61, 0x6c, 0x69, 0x64,
    0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x3a, 0x20, 0x53, 0x74, 0x65, 0x70,
    0x2c, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x43, 0x6f, 0x6e, 0x63, 0x65,
    0x70, 0x74, 0x2c, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x2c, 0x20, 0x54, 0x61,
    0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69,
    0x6f, 0x2c, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x54, 0x61, 0x67, 0x73, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x04, 0x00, 0x01, 0x12, 0x03, 0x2d, 0x09, 0x11, 0x0a, 0x1f, 0x0a,
    0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x2e, 0x08, 0x11, 0x22, 0x10, 0x20, 0x49,
    0x74, 0x65, 0x6d, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x53, 0x74, 0x65, 0x70, 0x0a, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x2e, 0x08, 0x0c, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x2e, 0x0f, 0x10, 0x0a, 0x22,
    0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x2f, 0x08, 0x14, 0x22, 0x13, 0x20,
    0x49, 0x74, 0x65, 0x6d, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
    0x74, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x2f,
    0x08, 0x0f, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x2f,
    0x12, 0x13, 0x0a, 0x22, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x30, 0x08,
    0x14, 0x22, 0x13, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x43, 0x6f,
    0x6e, 0x63, 0x65, 0x70, 0x74, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x03, 0x30, 0x08, 0x0f, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02,
    0x02, 0x12, 0x03, 0x30, 0x12, 0x13, 0x0a, 0x23, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x03,
    0x12, 0x03, 0x31, 0x08, 0x15, 0x22, 0x14, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04,
    0x01, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x31, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x07, 0x04,
    0x01, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03, 0x31, 0x13, 0x14, 0x0a, 0x7b, 0x0a, 0x06, 0x04,
    0x01, 0x04, 0x00, 0x02, 0x04, 0x12, 0x03, 0x32, 0x08, 0x20, 0x22, 0x6c, 0x20, 0x49, 0x74, 0x65,
    0x6d, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x2c, 0x20, 0x61, 0x20, 0x73, 0x70,
    0x65, 0x63, 0x69, 0x61, 0x6c, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x53, 0x63,
    0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x2c, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74,
    0x20, 0x53, 0x74, 0x65, 0x70, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x61,
    0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00,
    0x02, 0x04, 0x01, 0x12, 0x03, 0x32, 0x08, 0x1b, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00,
    0x02, 0x04, 0x02, 0x12, 0x03, 0x32, 0x1e, 0x1f, 0x0a, 0x20, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00,
    0x02, 0x05, 0x12, 0x03, 0x33, 0x08, 0x12, 0x22, 0x11, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x20, 0x69,
    0x73, 0x20, 0x61, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x05, 0x01, 0x12, 0x03, 0x33, 0x08, 0x0d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x05, 0x02, 0x12, 0x03, 0x33, 0x10, 0x11, 0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x06, 0x12, 0x03, 0x34, 0x08, 0x11, 0x22, 0x0f, 0x20, 0x49, 0x74, 0x65, 0x6d,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x54, 0x61, 0x67, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x34, 0x08, 0x0c, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01,
    0x04, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x34, 0x0f, 0x10, 0x0a, 0x31, 0x0a, 0x04, 0x04, 0x01,
    0x02, 0x00, 0x12, 0x03, 0x37, 0x04, 0x23, 0x1a, 0x24, 0x2f, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x74,
    0x79, 0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65,
    0x6e, 0x74, 0x20, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x49, 0x74, 0x65, 0x6d, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x37, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x00, 0x06, 0x12, 0x03, 0x37, 0x0d, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x37, 0x16, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03,
    0x12, 0x03, 0x37, 0x21, 0x22, 0x0a, 0x48, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x01, 0x12, 0x03, 0x39,
    0x04, 0x20, 0x1a, 0x3b, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x53, 0x74, 0x65, 0x70, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x49,
    0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x53, 0x74, 0x65, 0x70, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x04, 0x12, 0x03, 0x39, 0x04, 0x0c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x01, 0x06, 0x12, 0x03, 0x39, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x39, 0x17, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x01, 0x03, 0x12, 0x03, 0x39, 0x1e, 0x1f, 0x0a, 0x4e, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x02, 0x12,
    0x03, 0x3b, 0x04, 0x26, 0x1a, 0x41, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x43, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79,
    0x20, 0x69, 0x66, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x43,
    0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x04,
    0x12, 0x03, 0x3b, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x06, 0x12, 0x03,
    0x3b, 0x0d, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x01, 0x12, 0x03, 0x3b, 0x1a,
    0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x03, 0x12, 0x03, 0x3b, 0x24, 0x25, 0x0a,
    0x50, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x03, 0x12, 0x03, 0x3d, 0x04, 0x28, 0x1a, 0x43, 0x2f, 0x20,
    0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72,
    0x69, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x56,
    0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x49, 0x74, 0x65,
    0x6d, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x04, 0x12, 0x03, 0x3d, 0x04, 0x0c, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x06, 0x12, 0x03, 0x3d, 0x0d, 0x1a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x03, 0x01, 0x12, 0x03, 0x3d, 0x1b, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x03, 0x03, 0x12, 0x03, 0x3d, 0x26, 0x27, 0x0a, 0x66, 0x0a, 0x04, 0x04, 0x01, 0x02,
    0x04, 0x12, 0x03, 0x3f, 0x04, 0x3e, 0x1a, 0x59, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x53,
    0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69,
    0x66, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x54, 0x61, 0x62,
    0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x04, 0x04, 0x12, 0x03, 0x3f, 0x04, 0x0c, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x04, 0x06, 0x12, 0x03, 0x3f, 0x0d, 0x25, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x04, 0x01, 0x12, 0x03, 0x3f, 0x26, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x04, 0x03, 0x12, 0x03, 0x3f, 0x3c, 0x3d, 0x0a, 0x4e, 0x0a, 0x04, 0x04, 0x01, 0x02,
    0x05, 0x12, 0x03, 0x41, 0x04, 0x26, 0x1a, 0x41, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x65, 0x66, 0x69,
    0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e,
    0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3d,
    0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x05, 0x04, 0x12, 0x03, 0x41, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x05, 0x06,
    0x12, 0x03, 0x41, 0x0d, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x05, 0x01, 0x12, 0x03,
    0x41, 0x1a, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x05, 0x03, 0x12, 0x03, 0x41, 0x24,
    0x25, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x06, 0x12, 0x03, 0x43, 0x04, 0x22, 0x1a, 0x3d,
    0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x54, 0x61, 0x62, 0x6c,
    0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x56, 0x61,
    0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x49, 0x74, 0x65, 0x6d,
    0x54, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x06, 0x04, 0x12, 0x03, 0x43, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x06, 0x06, 0x12, 0x03, 0x43, 0x0d, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x06, 0x01, 0x12, 0x03, 0x43, 0x18, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x06, 0x03,
    0x12, 0x03, 0x43, 0x20, 0x21, 0x0a, 0x48, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x07, 0x12, 0x03, 0x45,
    0x04, 0x20, 0x1a, 0x3b, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x54, 0x61, 0x67, 0x73, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x49,
    0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x54, 0x61, 0x67, 0x73, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x07, 0x04, 0x12, 0x03, 0x45, 0x04, 0x0c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x07, 0x06, 0x12, 0x03, 0x45, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x07, 0x01, 0x12, 0x03, 0x45, 0x17, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x07, 0x03, 0x12, 0x03, 0x45, 0x1e, 0x1f, 0x0a, 0x35, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x49,
    0x00, 0x60, 0x01, 0x1a, 0x29, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f,
    0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69,
    0x6e, 0x67, 0x20, 0x61, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x0a, 0x0a, 0x0a,
    0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x49, 0x08, 0x15, 0x0a, 0x2d, 0x0a, 0x04, 0x04, 0x02,
    0x02, 0x00, 0x12, 0x03, 0x4b, 0x04, 0x28, 0x1a, 0x20, 0x2f, 0x20, 0x48, 0x65, 0x61, 0x64, 0x69,
    0x6e, 0x67, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20,
    0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x00, 0x04, 0x12, 0x03, 0x4b, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x05,
    0x12, 0x03, 0x4b, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x4b, 0x14, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x4b, 0x26,
    0x27, 0x0a, 0x41, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x4d, 0x04, 0x1d, 0x1a, 0x34,
    0x2f, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61,
    0x74, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72,
    0x69, 0x6f, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x65, 0x64, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x04, 0x12, 0x03, 0x4d,
    0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x05, 0x12, 0x03, 0x4d, 0x0d, 0x11,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x01, 0x12, 0x03, 0x4d, 0x12, 0x18, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03, 0x12, 0x03, 0x4d, 0x1b, 0x1c, 0x0a, 0x5d, 0x0a, 0x04,
    0x04, 0x02, 0x02, 0x02, 0x12, 0x03, 0x4f, 0x04, 0x24, 0x1a, 0x50, 0x2f, 0x20, 0x43, 0x6f, 0x6c,
    0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65,
    0x78, 0x74, 0x20, 0x73, 0x74, 0x65, 0x70, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x43, 0x6f,
    0x6e, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x74, 0x65, 0x70, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20,
    0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x72, 0x75, 0x6e, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x02, 0x04, 0x12, 0x03, 0x4f, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x02, 0x06, 0x12, 0x03, 0x4f, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x01,
    0x12, 0x03, 0x4f, 0x17, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x03, 0x12, 0x03,
    0x4f, 0x22, 0x23, 0x0a, 0x7a, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x03, 0x51, 0x04, 0x29,
    0x1a, 0x6d, 0x2f, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f,
    0x66, 0x20, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x20, 0x61, 0x20,
    0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20,
    0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x53, 0x74, 0x65, 0x70, 0x73, 0x2c, 0x20,
    0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2c, 0x20, 0x54, 0x61, 0x67, 0x73, 0x2c, 0x20,
    0x54, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x53, 0x63, 0x65, 0x6e, 0x61,
    0x72, 0x69, 0x6f, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x04, 0x12, 0x03, 0x51, 0x04, 0x0c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x03, 0x06, 0x12, 0x03, 0x51, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x03, 0x01, 0x12, 0x03, 0x51, 0x17, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x03, 0x03, 0x12, 0x03, 0x51, 0x27, 0x28, 0x0a, 0x74, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12,
    0x03, 0x53, 0x04, 0x31, 0x1a, 0x67, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73,
    0x20, 0x61, 0x20, 0x27, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x27, 0x20, 0x68, 0x6f, 0x6f, 0x6b,
    0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x73, 0x20, 0x77,
    0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f,
    0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x60, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x68,
    0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x04, 0x04, 0x12, 0x03, 0x53, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x04, 0x06, 0x12, 0x03, 0x53, 0x0d, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x04, 0x01, 0x12, 0x03, 0x53, 0x1e, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x03,
    0x12, 0x03, 0x53, 0x2f, 0x30, 0x0a, 0x72, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x03, 0x55,
    0x04, 0x32, 0x1a, 0x65, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61,
    0x20, 0x27, 0x61, 0x66, 0x74, 0x65, 0x72, 0x27, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x54,
    0x68, 0x69, 0x73, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x61, 0x66, 0x74, 0x65, 0x72, 0x5f, 0x73, 0x63, 0x65, 0x6e,
    0x61, 0x72, 0x69, 0x6f, 0x60, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61,
    0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x05, 0x04, 0x12, 0x03, 0x55, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x06,
    0x12, 0x03, 0x55, 0x0d, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x01, 0x12, 0x03,
    0x55, 0x1e, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x03, 0x12, 0x03, 0x55, 0x30,
    0x31, 0x0a, 0x78, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x06, 0x12, 0x03, 0x57, 0x04, 0x1d, 0x1a, 0x6b,
    0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61, 0x20, 0x6c, 0x69, 0x73,
    0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x61, 0x67, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x6c, 0x65, 0x76, 0x65, 0x6c, 0x2e, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x20,
    0x74, 0x61, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x72, 0x65,
    0x73, 0x65, 0x6e, 0x74, 0x20, 0x68, 0x65, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x06, 0x04, 0x12, 0x03, 0x57, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x06, 0x05, 0x12, 0x03, 0x57, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06, 0x01,
    0x12, 0x03, 0x57, 0x14, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06, 0x03, 0x12, 0x03,
    0x57, 0x1b, 0x1c, 0x0a, 0x41, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x07, 0x12, 0x03, 0x59, 0x04, 0x25,
    0x1a, 0x34, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69,
    0x6d, 0x65, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x63, 0x65, 0x6e,
    0x61, 0x72, 0x69, 0x6f, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x04, 0x12,
    0x03, 0x59, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x05, 0x12, 0x03, 0x59,
    0x0d, 0x12, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x01, 0x12, 0x03, 0x59, 0x13, 0x20,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x03, 0x12, 0x03, 0x59, 0x23, 0x24, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x02, 0x02, 0x08, 0x12, 0x03, 0x5a, 0x04, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x08, 0x04, 0x12, 0x03, 0x5a, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x08, 0x05, 0x12, 0x03, 0x5a, 0x0d, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x08, 0x01,
    0x12, 0x03, 0x5a, 0x12, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x08, 0x03, 0x12, 0x03,
    0x5a, 0x1c, 0x1d, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x09, 0x12, 0x03, 0x5b, 0x04, 0x24,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x09, 0x04, 0x12, 0x03, 0x5b, 0x04, 0x0c, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x09, 0x05, 0x12, 0x03, 0x5b, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x09, 0x01, 0x12, 0x03, 0x5b, 0x14, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x09, 0x03, 0x12, 0x03, 0x5b, 0x21, 0x23, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x0a,
    0x12, 0x03, 0x5d, 0x04, 0x1c, 0x1a, 0x2d, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69,
    0x66, 0x69, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72,
    0x69, 0x6f, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x0a, 0x04, 0x12, 0x03, 0x5d,
    0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x0a, 0x05, 0x12, 0x03, 0x5d, 0x0d, 0x13,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x0a, 0x01, 0x12, 0x03, 0x5d, 0x14, 0x16, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x0a, 0x03, 0x12, 0x03, 0x5d, 0x19, 0x1b, 0x0a, 0x5e, 0x0a, 0x04,
    0x04, 0x02, 0x02, 0x0b, 0x12, 0x03, 0x5f, 0x04, 0x2a, 0x1a, 0x51, 0x2f, 0x20, 0x43, 0x6f, 0x6c,
    0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x54, 0x65, 0x61, 0x72, 0x64,
    0x6f, 0x77, 0x6e, 0x20, 0x73, 0x74, 0x65, 0x70, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x54,
    0x65, 0x61, 0x72, 0x64, 0x6f, 0x77, 0x6e, 0x20, 0x73, 0x74, 0x65, 0x70, 0x73, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72,
    0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x72, 0x75, 0x6e, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x0b, 0x04, 0x12, 0x03, 0x5f, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x0b, 0x06, 0x12, 0x03, 0x5f, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x0b,
    0x01, 0x12, 0x03, 0x5f, 0x17, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x0b, 0x03, 0x12,
    0x03, 0x5f, 0x27, 0x29, 0x0a, 0x40, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04, 0x63, 0x00, 0x66, 0x01,
    0x1a, 0x34, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65,
    0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20,
    0x61, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x53, 0x63, 0x65,
    0x6e, 0x61, 0x72, 0x69, 0x6f, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x63,
    0x08, 0x20, 0x0a, 0x5a, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03, 0x65, 0x04, 0x29, 0x1a,
    0x4d, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x6e, 0x64,
    0x65, 0x72, 0x6c, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65,
    0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x72, 0x6f, 0x77, 0x20,
    0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x65, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x00, 0x06, 0x12, 0x03, 0x65, 0x0d, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x65, 0x1b, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x65, 0x27, 0x28, 0x0a, 0x31, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0x69, 0x00,
    0x72, 0x01, 0x1a, 0x25, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62,
    0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e,
    0x67, 0x20, 0x61, 0x20, 0x53, 0x74, 0x65, 0x70, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x04, 0x01,
    0x12, 0x03, 0x69, 0x08, 0x11, 0x0a, 0x76, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x00, 0x12, 0x03, 0x6b,
    0x04, 0x23, 0x1a, 0x69, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x72, 0x61, 0x77, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x53, 0x74, 0x65, 0x70, 0x20, 0x61, 0x73, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20,
    0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x20, 0x66, 0x69, 0x6c, 0x65,
    0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    0x65, 0x74, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x03, 0x6b, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x00, 0x05, 0x12, 0x03, 0x6b, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x6b, 0x14, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03,
    0x12, 0x03, 0x6b, 0x21, 0x22, 0x0a, 0x65, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x01, 0x12, 0x03, 0x6d,
    0x04, 0x23, 0x1a, 0x58, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x65, 0x70, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65,
    0x68, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x01, 0x04, 0x12, 0x03, 0x6d, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x01, 0x05, 0x12, 0x03, 0x6d, 0x0d, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01,
    0x01, 0x12, 0x03, 0x6d, 0x14, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x03, 0x12,
    0x03, 0x6d, 0x21, 0x22, 0x0a, 0x6b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x02, 0x12, 0x03, 0x6f, 0x04,
    0x24, 0x1a, 0x5e, 0x2f, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x6f, 0x66, 0x20, 0x61, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x66, 0x72, 0x61,
    0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x53, 0x74, 0x65,
    0x70, 0x2e, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x63, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x65,
    0x78, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12, 0x03, 0x6f, 0x04, 0x0c, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x06, 0x12, 0x03, 0x6f, 0x0d, 0x15, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x6f, 0x16, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x02, 0x03, 0x12, 0x03, 0x6f, 0x22, 0x23, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x04, 0x02,
    0x03, 0x12, 0x03, 0x71, 0x04, 0x3e, 0x1a, 0x27, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x04, 0x12, 0x03, 0x71, 0x04, 0x0c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x04, 0x02, 0x03, 0x06, 0x12, 0x03, 0x71, 0x0d, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x03, 0x01, 0x12, 0x03, 0x71, 0x26, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x03, 0x03, 0x12, 0x03, 0x71, 0x3c, 0x3d, 0x0a, 0xb6, 0x01, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x04,
    0x77, 0x00, 0x7e, 0x01, 0x1a, 0xa9, 0x01, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x74,
    0x65, 0x70, 0x2c, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x68, 0x61, 0x76,
    0x65, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x53, 0x74, 0x65, 0x70, 0x73,
    0x2e, 0x0a, 0x2f, 0x20, 0x42, 0x75, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x63,
    0x61, 0x6c, 0x6c, 0x65, 0x72, 0x27, 0x73, 0x20, 0x70, 0x65, 0x72, 0x73, 0x70, 0x65, 0x63, 0x74,
    0x69, 0x76, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x74, 0x69, 0x6c, 0x6c,
    0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x6f, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x53, 0x74, 0x65, 0x70, 0x0a, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65,
    0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x0a,
    0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x03, 0x77, 0x08, 0x14, 0x0a, 0x37, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x00, 0x12, 0x03, 0x79, 0x04, 0x27, 0x1a, 0x2a, 0x2f, 0x20, 0x52, 0x65, 0x70,
    0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x65, 0x70,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x63,
    0x65, 0x70, 0x74, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x03,
    0x79, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x06, 0x12, 0x03, 0x79, 0x0d,
    0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x79, 0x17, 0x22, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x03, 0x79, 0x25, 0x26, 0x0a, 0x3a, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x01, 0x12, 0x03, 0x7b, 0x04, 0x21, 0x1a, 0x2d, 0x2f, 0x20, 0x43, 0x6f,
    0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x53, 0x74, 0x65, 0x70,
    0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x63,
    0x6f, 0x6e, 0x63, 0x65, 0x70, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x01, 0x04, 0x12, 0x03, 0x7b, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x06,
    0x12, 0x03, 0x7b, 0x0d, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x01, 0x12, 0x03,
    0x7b, 0x17, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x03, 0x12, 0x03, 0x7b, 0x1f,
    0x20, 0x0a, 0x2b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x02, 0x12, 0x03, 0x7d, 0x04, 0x41, 0x1a, 0x1e,
    0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x03, 0x7d, 0x04, 0x0c, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x02, 0x06, 0x12, 0x03, 0x7d, 0x0d, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x7d, 0x26, 0x3c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x7d, 0x3f, 0x40, 0x0a, 0x31, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x06, 0x81, 0x01,
    0x00, 0x84, 0x01, 0x01, 0x1a, 0x23, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20,
    0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74,
    0x69, 0x6e, 0x67, 0x20, 0x54, 0x61, 0x67, 0x73, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x06, 0x01,
    0x12, 0x04, 0x81, 0x01, 0x08, 0x11, 0x0a, 0x25, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x04,
    0x83, 0x01, 0x04, 0x1d, 0x1a, 0x17, 0x2f, 0x20, 0x41, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x54, 0x61, 0x67, 0x73, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x04, 0x83, 0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x01, 0x14, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x83, 0x01, 0x1b, 0x1c, 0x0a, 0x5f, 0x0a, 0x02, 0x04, 0x07, 0x12,
    0x06, 0x88, 0x01, 0x00, 0x94, 0x01, 0x01, 0x1a, 0x51, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73,
    0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x2e,
    0x0a, 0x2f, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2c, 0x20, 0x70, 0x75,
    0x74, 0x20, 0x74, 0x6f, 0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20,
    0x75, 0x70, 0x20, 0x41, 0x20, 0x53, 0x74, 0x65, 0x70, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x07,
    0x01, 0x12, 0x04, 0x88, 0x01, 0x08, 0x10, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x07, 0x04, 0x00, 0x12,
    0x06, 0x8a, 0x01, 0x04, 0x8d, 0x01, 0x05, 0x1a, 0x2a, 0x2f, 0x20, 0x45, 0x6e, 0x75, 0x6d, 0x20,
    0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65,
    0x6e, 0x74, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x04, 0x00, 0x01, 0x12, 0x04, 0x8a, 0x01,
    0x09, 0x15, 0x0a, 0x2a, 0x0a, 0x06, 0x04, 0x07, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0x8b, 0x01,
    0x08, 0x11, 0x22, 0x1a, 0x2f, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x69,
    0x73, 0x20, 0x61, 0x20, 0x54, 0x65, 0x78, 0x74, 0x20, 0x70, 0x61, 0x72, 0x74, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8b, 0x01, 0x08, 0x0c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0x8b, 0x01, 0x0f, 0x10,
    0x0a, 0x2f, 0x0a, 0x06, 0x04, 0x07, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x08, 0x16,
    0x22, 0x1f, 0x2f, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x20, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x20, 0x70, 0x61, 0x72, 0x74,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c, 0x01,
    0x08, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x07, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0x8c,
    0x01, 0x14, 0x15, 0x0a, 0x43, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x04, 0x8f, 0x01, 0x04,
    0x2b, 0x1a, 0x35, 0x2f, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x46, 0x72, 0x61,
    0x67, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x54, 0x65, 0x78, 0x74, 0x2c, 0x20, 0x50, 0x61,
    0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x8f, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x06,
    0x12, 0x04, 0x8f, 0x01, 0x0d, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x8f, 0x01, 0x1a, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x8f, 0x01, 0x29, 0x2a, 0x0a, 0x4b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x01, 0x12, 0x04, 0x91, 0x01,
    0x04, 0x1d, 0x1a, 0x3d, 0x2f, 0x20, 0x54, 0x65, 0x78, 0x74, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x2c,
    0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x46,
    0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x3d, 0x54, 0x65, 0x78, 0x74,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x04, 0x12, 0x04, 0x91, 0x01, 0x04, 0x0c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x05, 0x12, 0x04, 0x91, 0x01, 0x0d, 0x13, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x01, 0x12, 0x04, 0x91, 0x01, 0x14, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x03, 0x12, 0x04, 0x91, 0x01, 0x1b, 0x1c, 0x0a, 0x55, 0x0a,
    0x04, 0x04, 0x07, 0x02, 0x02, 0x12, 0x04, 0x93, 0x01, 0x04, 0x25, 0x1a, 0x47, 0x2f, 0x20, 0x50,
    0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x76,
    0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x46, 0x72, 0x61,
    0x67, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x3d, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
    0x74, 0x65, 0x72, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x04, 0x12, 0x04, 0x93,
    0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x06, 0x12, 0x04, 0x93, 0x01,
    0x0d, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x01, 0x12, 0x04, 0x93, 0x01, 0x17,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x03, 0x12, 0x04, 0x93, 0x01, 0x23, 0x24,
    0x0a, 0x36, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0x97, 0x01, 0x00, 0xa8, 0x01, 0x01, 0x1a, 0x28,
    0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
    0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x46, 0x72,
    0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12,
    0x04, 0x97, 0x01, 0x08, 0x11, 0x0a, 0x38, 0x0a, 0x04, 0x04, 0x08, 0x04, 0x00, 0x12, 0x06, 0x99,
    0x01, 0x04, 0x9f, 0x01, 0x05, 0x1a, 0x28, 0x2f, 0x20, 0x45, 0x6e, 0x75, 0x6d, 0x20, 0x72, 0x65,
    0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73,
    0x20, 0x6f, 0x66, 0x20, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x04, 0x00, 0x01, 0x12, 0x04, 0x99, 0x01, 0x09, 0x16, 0x0a, 0x56,
    0x0a, 0x06, 0x04, 0x08, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0x9a, 0x01, 0x08, 0x13, 0x22, 0x46,
    0x20, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
    0x72, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73,
    0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x53, 0x74, 0x65, 0x70, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x9a, 0x01, 0x08, 0x0e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02,
    0x00, 0x02, 0x12, 0x04, 0x9a, 0x01, 0x11, 0x12, 0x0a, 0x99, 0x01, 0x0a, 0x06, 0x04, 0x08, 0x04,
    0x00, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x01, 0x08, 0x14, 0x22, 0x88, 0x01, 0x20, 0x44, 0x79, 0x6e,
    0x61, 0x6d, 0x69, 0x63, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x20,
    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65,
    0x74, 0x65, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x68, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x2c,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x6a, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x61, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2c, 0x20, 0x64, 0x65,
    0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61,
    0x6c, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x9b, 0x01, 0x08, 0x0f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02, 0x01, 0x02,
    0x12, 0x04, 0x9b, 0x01, 0x12, 0x13, 0x0a, 0x62, 0x0a, 0x06, 0x04, 0x08, 0x04, 0x00, 0x02, 0x02,
    0x12, 0x04, 0x9c, 0x01, 0x08, 0x1b, 0x22, 0x52, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c,
    0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x74, 0x65, 0x72, 0x2c, 0x20, 0x74, 0x61, 0x6b, 0x69, 0x6e,
    0x67, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x2e, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x74,
    0x65, 0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x72, 0x6f,
    0x6d, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08,
    0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9c, 0x01, 0x08, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x08, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0x9c, 0x01, 0x19, 0x1a, 0x0a, 0x61, 0x0a, 0x06,
    0x04, 0x08, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x1a, 0x22, 0x51, 0x20, 0x53,
    0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x74, 0x65, 0x72, 0x2c,
    0x20, 0x74, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x61, 0x72, 0x61,
    0x6d, 0x65, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x72,
    0x6f, 0x6d, 0x20, 0x61, 0x20, 0x63, 0x73, 0x76, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x15,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0x9d, 0x01, 0x18,
    0x19, 0x0a, 0x44, 0x0a, 0x06, 0x04, 0x08, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0x9e, 0x01, 0x08,
    0x12, 0x22, 0x34, 0x20, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61,
    0x6d, 0x65, 0x74, 0x65, 0x72, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x64, 0x61, 0x74, 0x61, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00, 0x02,
    0x04, 0x01, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x08, 0x04, 0x00,
    0x02, 0x04, 0x02, 0x12, 0x04, 0x9e, 0x01, 0x10, 0x11, 0x0a, 0x6b, 0x0a, 0x04, 0x04, 0x08, 0x02,
    0x00, 0x12, 0x04, 0xa1, 0x01, 0x04, 0x2d, 0x1a, 0x5d, 0x2f, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
    0x2e, 0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x3a, 0x20,
    0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x2c, 0x20, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x2c,
    0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x5f, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2c,
    0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x5f, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20,
    0x54, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xa1, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xa1, 0x01, 0x0d, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa1,
    0x01, 0x1b, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa1, 0x01,
    0x2b, 0x2c, 0x0a, 0x31, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x01, 0x04, 0x1e,
    0x1a, 0x23, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    0x65, 0x74, 0x65, 0x72, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa3, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3,
    0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x01,
    0x14, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa3, 0x01, 0x1c,
    0x1d, 0x0a, 0x52, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x02, 0x12, 0x04, 0xa5, 0x01, 0x04, 0x1d, 0x1a,
    0x44, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
    0x65, 0x72, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x4b, 0x65, 0x79, 0x20,
    0x74, 0x6f, 0x20, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xa5, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa5,
    0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x01,
    0x14, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x01, 0x1b,
    0x1c, 0x0a, 0x4f, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x03, 0x12, 0x04, 0xa7, 0x01, 0x04, 0x22, 0x1a,
    0x41, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62,
    0x6c, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x70, 0x61, 0x72,
    0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x3d, 0x54, 0x61, 0x62, 0x6c, 0x65,
    0x20, 0x6f, 0x72, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x5f, 0x54, 0x61, 0x62, 0x6c,
    0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa7, 0x01, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x06, 0x12, 0x04, 0xa7, 0x01, 0x0d, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa7, 0x01, 0x18, 0x1d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa7, 0x01, 0x20, 0x21, 0x0a, 0x35,
    0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xab, 0x01, 0x00, 0xae, 0x01, 0x01, 0x1a, 0x27, 0x2f, 0x20,
    0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72,
    0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x6f, 0x6d, 0x6d,
    0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xab, 0x01,
    0x08, 0x14, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xad, 0x01, 0x04, 0x1d,
    0x1a, 0x21, 0x2f, 0x20, 0x54, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65,
    0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
    0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xad, 0x01,
    0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x04, 0xad, 0x01, 0x0d,
    0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xad, 0x01, 0x14, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xad, 0x01, 0x1b, 0x1c, 0x0a,
    0x33, 0x0a, 0x02, 0x04, 0x0a, 0x12, 0x06, 0xb1, 0x01, 0x00, 0xb6, 0x01, 0x01, 0x1a, 0x25, 0x2f,
    0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20,
    0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x54, 0x61, 0x62,
    0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0xb1, 0x01, 0x08,
    0x12, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0xb3, 0x01, 0x04, 0x27, 0x1a,
    0x25, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x74, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb3, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xb3, 0x01, 0x0d, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb3,
    0x01, 0x1b, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb3, 0x01,
    0x25, 0x26, 0x0a, 0x30, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x04, 0x24,
    0x1a, 0x22, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x52, 0x6f, 0x77, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61,
    0x62, 0x6c, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb5,
    0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x06, 0x12, 0x04, 0xb5, 0x01,
    0x0d, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x1b,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x22, 0x23,
    0x0a, 0x33, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0xb9, 0x01, 0x00, 0xbc, 0x01, 0x01, 0x1a, 0x25,
    0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
    0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x54, 0x61,
    0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12, 0x04, 0xb9, 0x01,
    0x08, 0x15, 0x0a, 0x36, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x01, 0x04, 0x1e,
    0x1a, 0x28, 0x2f, 0x20, 0x52, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x65, 0x6c, 0x6c, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x67, 0x69,
    0x76, 0x65, 0x6e, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xbb, 0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbb, 0x01, 0x14, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xbb, 0x01, 0x1c, 0x1d, 0x0a, 0x42, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xbf, 0x01,
    0x00, 0xc9, 0x01, 0x01, 0x1a, 0x34, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20,
    0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74,
    0x69, 0x6e, 0x67, 0x20, 0x53, 0x74, 0x65, 0x70, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0c,
    0x01, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x20, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x00, 0x12,
    0x04, 0xc1, 0x01, 0x04, 0x36, 0x1a, 0x25, 0x2f, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74,
    0x75, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc1, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc1, 0x01, 0x0d, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x22, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xc1, 0x01, 0x34, 0x35, 0x0a, 0x71, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01,
    0x12, 0x04, 0xc3, 0x01, 0x04, 0x31, 0x1a, 0x63, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x73, 0x20, 0x61, 0x20, 0x27, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x27, 0x20, 0x68, 0x6f,
    0x6f, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x73,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x62, 0x65, 0x66, 0x6f, 0x72,
    0x65, 0x5f, 0x73, 0x74, 0x65, 0x70, 0x60, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x68, 0x61, 0x73,
    0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc3, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x01, 0x06, 0x12, 0x04, 0xc3, 0x01, 0x0d, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xc3, 0x01, 0x1e, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xc3, 0x01, 0x2f, 0x30, 0x0a, 0x6f, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x02, 0x12,
    0x04, 0xc5, 0x01, 0x04, 0x32, 0x1a, 0x61, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x73, 0x20, 0x61, 0x20, 0x27, 0x61, 0x66, 0x74, 0x65, 0x72, 0x27, 0x20, 0x68, 0x6f, 0x6f, 0x6b,
    0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x73, 0x20, 0x77,
    0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x61, 0x66, 0x74, 0x65, 0x72, 0x5f, 0x73,
    0x74, 0x65, 0x70, 0x60, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6e,
    0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xc5, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xc5, 0x01, 0x0d, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xc5, 0x01, 0x1e, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xc5, 0x01, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x03, 0x12, 0x04, 0xc7, 0x01,
    0x04, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc7, 0x01, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc7, 0x01, 0x0d, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc7, 0x01, 0x12, 0x19, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc7, 0x01, 0x1c, 0x1d, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0c, 0x02, 0x04, 0x12, 0x04, 0xc8, 0x01, 0x04, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc8, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x04, 0x05, 0x12, 0x04, 0xc8, 0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xc8, 0x01, 0x14, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xc8, 0x01, 0x24, 0x25, 0x0a, 0x47, 0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06,
    0xcc, 0x01, 0x00, 0xe2, 0x01, 0x01, 0x1a, 0x39, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65,
    0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74,
    0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x04, 0xcc, 0x01, 0x08, 0x1c, 0x0a, 0x29,
    0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00, 0x12, 0x04, 0xce, 0x01, 0x04, 0x1d, 0x1a, 0x1b, 0x2f, 0x20,
    0x46, 0x6c, 0x61, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xce, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xce, 0x01, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xce, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xce, 0x01, 0x1b, 0x1c, 0x0a, 0x43, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0xd0,
    0x01, 0x04, 0x27, 0x1a, 0x35, 0x2f, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x69,
    0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65,
    0x72, 0x72, 0x6f, 0x72, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x61,
    0x62, 0x6c, 0x65, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xd0, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xd0, 0x01, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xd0, 0x01, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xd0, 0x01, 0x25, 0x26, 0x0a, 0x2a, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x02, 0x12, 0x04,
    0xd2, 0x01, 0x04, 0x25, 0x1a, 0x1c, 0x2f, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x75,
    0x61, 0x6c, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd2, 0x01, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd2, 0x01, 0x0d, 0x13,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd2, 0x01, 0x14, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd2, 0x01, 0x23, 0x24, 0x0a, 0x28,
    0x0a, 0x04, 0x04, 0x0d, 0x02, 0x03, 0x12, 0x04, 0xd4, 0x01, 0x04, 0x23, 0x1a, 0x1a, 0x2f, 0x20,
    0x53, 0x74, 0x61, 0x63, 0x6b, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xd4, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xd4, 0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xd4, 0x01, 0x14, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xd4, 0x01, 0x21, 0x22, 0x0a, 0x4f, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x04, 0x12, 0x04, 0xd6, 0x01,
    0x04, 0x22, 0x1a, 0x41, 0x2f, 0x20, 0x42, 0x79, 0x74, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79,
    0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x63, 0x72, 0x65,
    0x65, 0x6e, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20, 0x61, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x66, 0x61, 0x69, 0x6c,
    0x75, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xd6, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd6,
    0x01, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd6, 0x01,
    0x13, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd6, 0x01, 0x20,
    0x21, 0x0a, 0x42, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x05, 0x12, 0x04, 0xd8, 0x01, 0x04, 0x25, 0x1a,
    0x34, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d,
    0x65, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x63, 0x65, 0x6e, 0x61,
    0x72, 0x69, 0x6f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xd8, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd8,
    0x01, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd8, 0x01,
    0x13, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd8, 0x01, 0x23,
    0x24, 0x0a, 0x4f, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x06, 0x12, 0x04, 0xda, 0x01, 0x04, 0x20, 0x1a,
    0x41, 0x2f, 0x20, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x69, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x74, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x61, 0x76, 0x61,
    0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74,
    0x73, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x04, 0x12, 0x04, 0xda, 0x01, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x05, 0x12, 0x04, 0xda, 0x01, 0x0d, 0x13,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x01, 0x12, 0x04, 0xda, 0x01, 0x14, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x03, 0x12, 0x04, 0xda, 0x01, 0x1e, 0x1f, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x0d, 0x04, 0x00, 0x12, 0x06, 0xdc, 0x01, 0x04, 0xdf, 0x01, 0x05, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x04, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x09, 0x12, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x0d, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x01, 0x08, 0x16, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0d, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x01, 0x08, 0x11, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0d, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xdd, 0x01, 0x14, 0x15, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x0d, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xde, 0x01, 0x08, 0x19, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xde, 0x01, 0x08, 0x14,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xde, 0x01, 0x17,
    0x18, 0x0a, 0x5d, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x07, 0x12, 0x04, 0xe1, 0x01, 0x04, 0x3b, 0x1a,
    0x4f, 0x2f, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x45,
    0x72, 0x72, 0x6f, 0x72, 0x2e, 0x20, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x73, 0x3a, 0x20, 0x41, 0x53, 0x53, 0x45, 0x52, 0x54, 0x49, 0x4f, 0x4e, 0x2c, 0x20, 0x56,
    0x45, 0x52, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x2e, 0x20, 0x44, 0x65, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x3a, 0x20, 0x41, 0x53, 0x53, 0x45, 0x52, 0x54, 0x49, 0x4f, 0x4e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x07, 0x04, 0x12, 0x04, 0xe1, 0x01, 0x04, 0x0c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x07, 0x06, 0x12, 0x04, 0xe1, 0x01, 0x0d, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x07, 0x01, 0x12, 0x04, 0xe1, 0x01, 0x17, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x07, 0x03, 0x12, 0x04, 0xe1, 0x01, 0x23, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x07, 0x08, 0x12, 0x04, 0xe1, 0x01, 0x25, 0x3a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x07, 0x07, 0x12, 0x04, 0xe1, 0x01, 0x30, 0x39, 0x0a, 0xaa, 0x01, 0x0a, 0x02, 0x04,
    0x0e, 0x12, 0x06, 0xe6, 0x01, 0x00, 0xed, 0x01, 0x01, 0x1a, 0x9b, 0x01, 0x2f, 0x20, 0x41, 0x20,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70,
    0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x2d,
    0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x2e, 0x0a, 0x2f, 0x20,
    0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x68, 0x6f, 0x6c, 0x64, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x73, 0x75, 0x69, 0x74,
    0x65, 0x2c, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x2c, 0x20,
    0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x73, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x20,
    0x68, 0x6f, 0x6f, 0x6b, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04,
    0xe6, 0x01, 0x08, 0x18, 0x0a, 0x2c, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x04, 0xe8, 0x01,
    0x04, 0x23, 0x1a, 0x1e, 0x2f, 0x20, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x74, 0x72, 0x61, 0x63, 0x65,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72,
    0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe8, 0x01, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe8, 0x01, 0x0d, 0x13,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe8, 0x01, 0x14, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe8, 0x01, 0x21, 0x22, 0x0a, 0x2f,
    0x0a, 0x04, 0x04, 0x0e, 0x02, 0x01, 0x12, 0x04, 0xea, 0x01, 0x04, 0x25, 0x1a, 0x21, 0x2f, 0x20,
    0x45, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x66, 0x72,
    0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xea, 0x01, 0x04, 0x0c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xea, 0x01, 0x0d, 0x13, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xea, 0x01, 0x14, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xea, 0x01, 0x23, 0x24, 0x0a, 0x50, 0x0a, 0x04, 0x04,
    0x0e, 0x02, 0x02, 0x12, 0x04, 0xec, 0x01, 0x04, 0x22, 0x1a, 0x42, 0x2f, 0x20, 0x42, 0x79, 0x74,
    0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x68, 0x6f, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x74,
    0x61, 0x6b, 0x65, 0x6e, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65,
    0x20, 0x6f, 0x66, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x02, 0x04, 0x12, 0x04, 0xec, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x02, 0x05, 0x12, 0x04, 0xec, 0x01, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x02, 0x01, 0x12, 0x04, 0xec, 0x01, 0x13, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xec, 0x01, 0x20, 0x21, 0x0a, 0x52, 0x0a, 0x02, 0x04, 0x0f, 0x12,
    0x06, 0xf0, 0x01, 0x00, 0x89, 0x02, 0x01, 0x1a, 0x44, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73,
    0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x20, 0x6f, 0x66, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x72, 0x65, 0x20, 0x53, 0x75, 0x69, 0x74,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xf0, 0x01, 0x08, 0x18, 0x0a, 0x37, 0x0a, 0x04, 0x04, 0x0f,
    0x02, 0x00, 0x12, 0x04, 0xf2, 0x01, 0x04, 0x2d, 0x1a, 0x29, 0x2f, 0x20, 0x43, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20,
    0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
    0x6f, 0x6e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf2, 0x01,
    0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x06, 0x12, 0x04, 0xf2, 0x01, 0x0d,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x1d, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2, 0x01, 0x2b, 0x2c, 0x0a,
    0x71, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x01, 0x12, 0x04, 0xf4, 0x01, 0x04, 0x31, 0x1a, 0x63, 0x2f,
    0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61, 0x20, 0x27, 0x62, 0x65, 0x66,
    0x6f, 0x72, 0x65, 0x27, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x60, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x73, 0x75, 0x69, 0x74, 0x65, 0x60, 0x20,
    0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f,
    0x72, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf4, 0x01, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x06, 0x12, 0x04, 0xf4, 0x01, 0x0d, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf4, 0x01, 0x1e, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf4, 0x01, 0x2f, 0x30, 0x0a, 0x6f,
    0x0a, 0x04, 0x04, 0x0f, 0x02, 0x02, 0x12, 0x04, 0xf6, 0x01, 0x04, 0x32, 0x1a, 0x61, 0x2f, 0x20,
    0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x61, 0x20, 0x27, 0x61, 0x66, 0x74, 0x65,
    0x72, 0x27, 0x20, 0x68, 0x6f, 0x6f, 0x6b, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x68, 0x61,
    0x70, 0x70, 0x65, 0x6e, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60,
    0x61, 0x66, 0x74, 0x65, 0x72, 0x5f, 0x73, 0x75, 0x69, 0x74, 0x65, 0x60, 0x20, 0x68, 0x6f, 0x6f,
    0x6b, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf6, 0x01, 0x04, 0x0c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x06, 0x12, 0x04, 0xf6, 0x01, 0x0d, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf6, 0x01, 0x1e, 0x2d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf6, 0x01, 0x30, 0x31, 0x0a, 0x29, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x03, 0x12, 0x04, 0xf8, 0x01, 0x04, 0x1d, 0x1a, 0x1b, 0x2f, 0x20, 0x46, 0x6c, 0x61,
    0x67, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x75, 0x72, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xf8, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xf8, 0x01, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf8,
    0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf8, 0x01,
    0x1b, 0x1c, 0x0a, 0x49, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x04, 0x12, 0x04, 0xfa, 0x01, 0x04, 0x28,
    0x1a, 0x3b, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f,
    0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66,
    0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x04, 0x04, 0x12, 0x04, 0xfa, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x04, 0x05, 0x12, 0x04, 0xfa, 0x01, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x04, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x13, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xfa, 0x01, 0x26, 0x27, 0x0a, 0x44, 0x0a, 0x04, 0x04, 0x0f, 0x02,
    0x05, 0x12, 0x04, 0xfc, 0x01, 0x04, 0x25, 0x1a, 0x36, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x77, 0x68, 0x6f, 0x6c, 0x65, 0x20, 0x73, 0x75, 0x69, 0x74, 0x65, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05, 0x04, 0x12, 0x04, 0xfc, 0x01, 0x04, 0x0c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05, 0x05, 0x12, 0x04, 0xfc, 0x01, 0x0d, 0x12, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x05, 0x01, 0x12, 0x04, 0xfc, 0x01, 0x13, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x05, 0x03, 0x12, 0x04, 0xfc, 0x01, 0x23, 0x24, 0x0a, 0x4d, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x06, 0x12, 0x04, 0xfe, 0x01, 0x04, 0x23, 0x1a, 0x3f, 0x2f, 0x20, 0x48, 0x6f, 0x6c,
    0x64, 0x73, 0x20, 0x61, 0x20, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x20, 0x69, 0x6e, 0x64, 0x69,
    0x63, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65,
    0x73, 0x73, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x06, 0x04, 0x12, 0x04, 0xfe, 0x01, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x06, 0x05, 0x12, 0x04, 0xfe, 0x01, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x06,
    0x01, 0x12, 0x04, 0xfe, 0x01, 0x13, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x06, 0x03,
    0x12, 0x04, 0xfe, 0x01, 0x21, 0x22, 0x0a, 0x41, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x07, 0x12, 0x04,
    0x80, 0x02, 0x04, 0x24, 0x1a, 0x33, 0x2f, 0x20, 0x54, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x76, 0x69,
    0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x73, 0x74, 0x20,
    0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x77, 0x61, 0x73, 0x20, 0x64, 0x6f, 0x6e, 0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x07, 0x04, 0x12, 0x04, 0x80, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x07,
    0x05, 0x12, 0x04, 0x80, 0x02, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x07, 0x01,
    0x12, 0x04, 0x80, 0x02, 0x14, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x07, 0x03, 0x12,
    0x04, 0x80, 0x02, 0x22, 0x23, 0x0a, 0x40, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x08, 0x12, 0x04, 0x82,
    0x02, 0x04, 0x1d, 0x1a, 0x32, 0x2f, 0x20, 0x54, 0x61, 0x67, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65,
    0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x66,
    0x69, 0x6c, 0x74, 0x65, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x08, 0x04,
    0x12, 0x04, 0x82, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x08, 0x05, 0x12,
    0x04, 0x82, 0x02, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x08, 0x01, 0x12, 0x04,
    0x82, 0x02, 0x14, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x08, 0x03, 0x12, 0x04, 0x82,
    0x02, 0x1b, 0x1c, 0x0a, 0x1d, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x09, 0x12, 0x04, 0x84, 0x02, 0x04,
    0x25, 0x1a, 0x0f, 0x2f, 0x20, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x6e, 0x61, 0x6d,
    0x65, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x09, 0x04, 0x12, 0x04, 0x84, 0x02, 0x04,
    0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x09, 0x05, 0x12, 0x04, 0x84, 0x02, 0x0d, 0x13,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x09, 0x01, 0x12, 0x04, 0x84, 0x02, 0x14, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x09, 0x03, 0x12, 0x04, 0x84, 0x02, 0x22, 0x24, 0x0a, 0x34,
    0x0a, 0x04, 0x04, 0x0f, 0x02, 0x0a, 0x12, 0x04, 0x86, 0x02, 0x04, 0x23, 0x1a, 0x26, 0x2f, 0x20,
    0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x6f, 0x66, 0x20, 0x77, 0x68, 0x65,
    0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x74, 0x61, 0x72,
    0x74, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x0a, 0x04, 0x12, 0x04, 0x86,
    0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x0a, 0x05, 0x12, 0x04, 0x86, 0x02,
    0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x86, 0x02, 0x14,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x0a, 0x03, 0x12, 0x04, 0x86, 0x02, 0x20, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x0b, 0x12, 0x04, 0x87, 0x02, 0x04, 0x2a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x0b, 0x04, 0x12, 0x04, 0x87, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x0b, 0x05, 0x12, 0x04, 0x87, 0x02, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x0b, 0x01, 0x12, 0x04, 0x87, 0x02, 0x13, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x0b, 0x03, 0x12, 0x04, 0x87, 0x02, 0x27, 0x29, 0x0a, 0x4a, 0x0a, 0x02, 0x04, 0x10,
    0x12, 0x06, 0x8c, 0x02, 0x00, 0x9b, 0x02, 0x01, 0x1a, 0x3c, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65,
    0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75,
    0x6c, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x53, 0x70, 0x65, 0x63, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0x8c,
    0x02, 0x08, 0x17, 0x0a, 0x3b, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x00, 0x12, 0x04, 0x8e, 0x02, 0x04,
    0x25, 0x1a, 0x2d, 0x2f, 0x20, 0x52, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x69, 0x6e,
    0x67, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8e, 0x02, 0x04, 0x0c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8e, 0x02, 0x0d, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8e, 0x02, 0x17, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8e, 0x02, 0x23, 0x24, 0x0a, 0x37, 0x0a, 0x04,
    0x04, 0x10, 0x02, 0x01, 0x12, 0x04, 0x90, 0x02, 0x04, 0x25, 0x1a, 0x29, 0x2f, 0x20, 0x48, 0x6f,
    0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f,
    0x66, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x90, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x05, 0x12, 0x04, 0x90,
    0x02, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x01, 0x12, 0x04, 0x90, 0x02,
    0x13, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x03, 0x12, 0x04, 0x90, 0x02, 0x23,
    0x24, 0x0a, 0x35, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x02, 0x12, 0x04, 0x92, 0x02, 0x04, 0x2b, 0x1a,
    0x27, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x75, 0x6d,
    0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x53, 0x63, 0x65, 0x6e, 0x61, 0x72, 0x69, 0x6f, 0x73,
    0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x92, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x92, 0x02, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x92, 0x02, 0x13, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x92, 0x02, 0x29, 0x2a, 0x0a, 0x29, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x03, 0x12, 0x04, 0x94, 0x02,
    0x04, 0x1d, 0x1a, 0x1b, 0x2f, 0x20, 0x46, 0x6c, 0x61, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e,
    0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x04, 0x12, 0x04, 0x94, 0x02, 0x04, 0x0c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x05, 0x12, 0x04, 0x94, 0x02, 0x0d, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x03, 0x01, 0x12, 0x04, 0x94, 0x02, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x03, 0x03, 0x12, 0x04, 0x94, 0x02, 0x1b, 0x1c, 0x0a, 0x4b, 0x0a, 0x04, 0x04,
    0x10, 0x02, 0x04, 0x12, 0x04, 0x96, 0x02, 0x04, 0x2b, 0x1a, 0x3d, 0x2f, 0x20, 0x48, 0x6f, 0x6c,
    0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x6f, 0x77, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65,
    0x72, 0x73, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74,
    0x6f, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04,
    0x04, 0x12, 0x04, 0x96, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x05,
    0x12, 0x04, 0x96, 0x02, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x01, 0x12,
    0x04, 0x96, 0x02, 0x13, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x03, 0x12, 0x04,
    0x96, 0x02, 0x29, 0x2a, 0x0a, 0x3d, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x05, 0x12, 0x04, 0x98, 0x02,
    0x04, 0x25, 0x1a, 0x2f, 0x2f, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x70, 0x65,
    0x63, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x04, 0x12, 0x04, 0x98, 0x02,
    0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x05, 0x12, 0x04, 0x98, 0x02, 0x0d,
    0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x01, 0x12, 0x04, 0x98, 0x02, 0x13, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x03, 0x12, 0x04, 0x98, 0x02, 0x23, 0x24, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x06, 0x12, 0x04, 0x99, 0x02, 0x04, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x06, 0x04, 0x12, 0x04, 0x99, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x06, 0x05, 0x12, 0x04, 0x99, 0x02, 0x0d, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x06, 0x01, 0x12, 0x04, 0x99, 0x02, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x06, 0x03, 0x12, 0x04, 0x99, 0x02, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02,
    0x07, 0x12, 0x04, 0x9a, 0x02, 0x04, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x04,
    0x12, 0x04, 0x9a, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x05, 0x12,
    0x04, 0x9a, 0x02, 0x0d, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x9a, 0x02, 0x13, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x07, 0x03, 0x12, 0x04, 0x9a,
    0x02, 0x2a, 0x2b, 0x0a, 0x3a, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0x9e, 0x02, 0x00, 0xa5, 0x02,
    0x01, 0x1a, 0x2c, 0x2f, 0x20, 0x41, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x6f, 0x62, 0x6a,
    0x65, 0x63, 0x74, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x61, 0x20, 0x53, 0x74, 0x65, 0x70, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x16, 0x0a, 0x3b, 0x0a, 0x04,
    0x04, 0x11, 0x02, 0x00, 0x12, 0x04, 0xa0, 0x02, 0x04, 0x22, 0x1a, 0x2d, 0x2f, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x61, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x69, 0x6e, 0x67,
    0x20, 0x68, 0x65, 0x20, 0x53, 0x74, 0x65, 0x70, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xa0, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xa0, 0x02, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xa0, 0x02, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xa0, 0x02, 0x20, 0x21, 0x0a, 0x72, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12, 0x04, 0xa2,
    0x02, 0x04, 0x2f, 0x1a, 0x64, 0x2f, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    0x65, 0x74, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x69, 0x6e, 0x67,
    0x20, 0x68, 0x65, 0x20, 0x53, 0x74, 0x65, 0x70, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x61,
    0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x70,
    0x6c, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65,
    0x68, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xa2, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xa2, 0x02, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa2, 0x02, 0x14, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xa2, 0x02, 0x2d, 0x2e, 0x0a, 0x45, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x02, 0x12, 0x04, 0xa4,
    0x02, 0x04, 0x23, 0x1a, 0x37, 0x2f, 0x20, 0x41, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x73, 0x20, 0x72,
    0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa4, 0x02, 0x04, 0x0c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa4, 0x02, 0x0d, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x14, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xa4, 0x02, 0x21, 0x22,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
